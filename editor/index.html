<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>JS Easy IDE</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			height: 100vh;
			overflow: hidden;
			background: #ffffff;
			color: #333333;
		}

		.toolbar {
			height: 50px;
			background: #f8f9fa;
			border-bottom: 1px solid #e9ecef;
			display: flex;
			align-items: center;
			padding: 0 20px;
			gap: 20px;
		}

		.toolbar button {
			background: #0e639c;
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background 0.2s;
		}

		.toolbar button:hover {
			background: #1177bb;
		}

		.toolbar button:disabled {
			background: #555;
			cursor: not-allowed;
		}

		.toolbar .spacer {
			flex: 1;
		}

		.toolbar a {
			color: #0066cc;
			text-decoration: none;
			font-size: 14px;
			transition: color 0.2s;
		}

		.toolbar a:hover {
			color: #004499;
		}

		.main-container {
			display: flex;
			height: calc(100vh - 50px);
		}

		.editor-container {
			flex: 1;
			display: flex;
			flex-direction: column;
			border-right: 1px solid #e9ecef;
		}

		.editor-header {
			background: #f8f9fa;
			padding: 10px 20px;
			border-bottom: 1px solid #e9ecef;
			font-size: 14px;
			color: #495057;
		}

		#monaco-editor {
			flex: 1;
			min-height: 0;
		}

		.preview-container {
			flex: 1;
			display: flex;
			flex-direction: column;
			background: #ffffff;
		}

		.preview-header {
			background: #f8f9fa;
			padding: 10px 20px;
			border-bottom: 1px solid #e9ecef;
			font-size: 14px;
			color: #495057;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.preview-title {
			display: flex;
			align-items: center;
		}

		.error-message {
			color: #dc3545;
			font-size: 12px;
			font-weight: bold;
			margin-left: 10px;
		}

		.preview-content {
			flex: 1;
			display: flex;
			flex-direction: column;
			min-height: 0;
		}

		#preview-frame {
			flex: 1;
			border: none;
			background: white;
			min-height: 0;
		}


		.hidden {
			display: none;
		}

		.file-input {
			display: none;
		}

		.status-indicator {
			display: inline-block;
			width: 8px;
			height: 8px;
			border-radius: 50%;
			margin-right: 8px;
		}

		.status-success {
			background: #4caf50;
		}

		.status-error {
			background: #f44336;
		}

		.status-loading {
			background: #ff9800;
			animation: pulse 1s infinite;
		}

		@keyframes pulse {
			0%, 100% { opacity: 1; }
			50% { opacity: 0.5; }
		}

		/* Monaco Editor Error Decorations */
		.monaco-error-underline {
			border-bottom: 2px solid #f14c4c;
			border-bottom-style: wavy;
			background-color: rgba(241, 76, 76, 0.1);
		}

		.monaco-warning-underline {
			border-bottom: 2px solid #ffa500;
			border-bottom-style: wavy;
			background-color: rgba(255, 165, 0, 0.1);
		}

		.monaco-info-underline {
			border-bottom: 2px solid #007acc;
			border-bottom-style: wavy;
			background-color: rgba(0, 122, 204, 0.1);
		}

		.monaco-error-glyph {
			background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTggMEMzLjU4IDAgMCAzLjU4IDAgOFMzLjU4IDE2IDggMTZTMTYgMTIuNDIgMTYgOFMxMi40MiAwIDggMFoiIGZpbGw9IiNmMTRjNGMiLz4KPHBhdGggZD0iTTggMTJBNCA0IDAgMSAwIDggNEE0IDQgMCAwIDAgOCAxMloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik04IDZIMTJWMTBIOFY2WiIgZmlsbD0iI2YxNGM0YyIvPgo8L3N2Zz4K') no-repeat center;
			width: 16px;
			height: 16px;
		}

		/* Modal Dialog Styles */
		.modal-overlay {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0, 0, 0, 0.5);
			z-index: 1000;
			justify-content: center;
			align-items: center;
		}

		.modal-overlay.active {
			display: flex;
		}

		.modal-dialog {
			background: white;
			border-radius: 8px;
			padding: 24px;
			width: 90%;
			max-width: 400px;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
		}

		.modal-header {
			font-size: 18px;
			font-weight: 600;
			margin-bottom: 20px;
			color: #333;
		}

		.modal-body {
			margin-bottom: 20px;
		}

		.modal-field {
			margin-bottom: 16px;
		}

		.modal-field label {
			display: block;
			margin-bottom: 6px;
			font-size: 14px;
			color: #555;
			font-weight: 500;
		}

		.modal-field input {
			width: 100%;
			padding: 8px 12px;
			border: 1px solid #ddd;
			border-radius: 4px;
			font-size: 14px;
			box-sizing: border-box;
		}

		.modal-field input:focus {
			outline: none;
			border-color: #0e639c;
			box-shadow: 0 0 0 2px rgba(14, 99, 156, 0.1);
		}

		.modal-footer {
			display: flex;
			justify-content: flex-end;
			gap: 10px;
		}

		.modal-btn {
			padding: 8px 16px;
			border: none;
			border-radius: 4px;
			font-size: 14px;
			cursor: pointer;
			transition: background 0.2s;
		}

		.modal-btn-primary {
			background: #0e639c;
			color: white;
		}

		.modal-btn-primary:hover:not(:disabled) {
			background: #1177bb;
		}

		.modal-btn-primary:disabled {
			background: #ccc;
			cursor: not-allowed;
		}

		.modal-btn-secondary {
			background: #e9ecef;
			color: #333;
		}

		.modal-btn-secondary:hover {
			background: #dee2e6;
		}

		.modal-status {
			margin-top: 12px;
			padding: 8px 12px;
			border-radius: 4px;
			font-size: 13px;
			display: none;
		}

		.modal-status.success {
			display: block;
			background: #d4edda;
			color: #155724;
			border: 1px solid #c3e6cb;
		}

		.modal-status.error {
			display: block;
			background: #f8d7da;
			color: #721c24;
			border: 1px solid #f5c6cb;
		}

		.modal-status.sending {
			display: block;
			background: #fff3cd;
			color: #856404;
			border: 1px solid #ffeeba;
		}

	/* Fullscreen styles */
	.fullscreen-preview {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		z-index: 9999;
		background: white;
		display: none;
	}

	.fullscreen-preview.active {
		display: block;
	}

	.fullscreen-preview iframe {
		width: 100%;
		height: 100%;
		border: none;
	}

	.fullscreen-close-btn {
		position: absolute;
		top: 10px;
		right: 10px;
		width: 50px;
		height: 50px;
		background: rgba(255, 0, 0, 0.8);
		color: white;
		border: 2px solid white;
		border-radius: 50%;
		cursor: pointer;
		font-size: 30px;
		font-weight: bold;
		line-height: 1;
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: 10001;
		transition: all 0.2s;
		box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
	}

	.fullscreen-close-btn:hover {
		background: rgba(255, 0, 0, 1);
		transform: scale(1.1);
		box-shadow: 0 6px 20px rgba(0, 0, 0, 0.7);
	}

	.fullscreen-close-btn:active {
		transform: scale(0.95);
	}
	</style>
	<!-- ESLint for browser -->
	<script src="https://cdn.jsdelivr.net/npm/eslint-linter-browserify@9.11.1/linter.js"></script>
	<link rel="shortcut icon" type="image/svg+xml" href="favicon.svg">
</head>
<body>
	<div class="toolbar">
		<button id="send-btn">‚úâÔ∏è Send</button>
		<button id="fullscreen-btn">üì± Fullscreen</button>
		<button id="list-btn">üîç List</button>
		<button id="chat-btn">üí¨ Chat</button>
		<button id="ai-btn">ü§ñ AI</button>
		<button id="new-btn">üìã New</button>
		<button id="load-btn">üìÇ Load</button>
		<button id="save-btn">üíæ Save</button>
		<button id="undo-btn">‚Ü©Ô∏è Undo</button>
		<button id="redo-btn">‚Ü™Ô∏è Redo</button>
		<button id="copy-btn">üìã Copy</button>
		<button id="paste-btn">üì• Paste</button>
		<button id="clear-storage-btn">üóëÔ∏è Clear</button>
		<button id="image-upload-btn">üñºÔ∏è Upload Image</button>
		<select id="github-example-select"></select>
		<input type="file" id="file-input" class="file-input" accept=".html,.js,.txt">
		<input type="file" id="image-input" class="file-input" accept="image/*">

		<div class="spacer"></div>

		<a href="https://github.com/vaclav-purchart/js-easy/" target="_blank">GitHub Repository</a>
		<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D" target="_blank">Canvas API Docs</a>
		<a href="https://code.visualstudio.com/" target="_blank">IDE</a>
		<a href="https://htmlcolorcodes.com/color-names/" target="_blank">HTML colors</a>

		<div class="spacer"></div>

		<span id="status-indicator" class="status-indicator status-success"></span>
		<span id="status-text">Ready</span>
	</div>

	<div class="main-container">
		<div class="editor-container">
			<div class="editor-header">
				<span class="status-indicator status-success"></span>
				Editor
			</div>
			<div id="monaco-editor"></div>
		</div>

		<div class="preview-container">
			<div class="preview-header">
				<div class="preview-title">
					<span id="preview-status-indicator" class="status-indicator status-success"></span>
					Preview
					<span id="error-message" class="error-message hidden"></span>
				</div>
			</div>
			<div class="preview-content">
				<iframe id="preview-frame" src="about:blank"></iframe>
			</div>
		</div>
	</div>

	<!-- Send Modal Dialog -->
	<div id="send-modal" class="modal-overlay">
		<div class="modal-dialog">
			<div class="modal-header">Send Project to Server</div>
			<div class="modal-body">
				<div class="modal-field">
					<label for="user-name-input">User Name:</label>
					<input type="text" id="user-name-input" placeholder="Enter your name">
				</div>
				<div class="modal-field">
					<label for="project-name-input">Project Name:</label>
					<input type="text" id="project-name-input" placeholder="Enter project name">
				</div>
				<div id="send-status" class="modal-status"></div>
			</div>
			<div class="modal-footer">
				<button id="send-cancel-btn" class="modal-btn modal-btn-secondary">Cancel</button>
				<button id="send-submit-btn" class="modal-btn modal-btn-primary">Send</button>
			</div>
		</div>
	</div>

	<!-- AI Modal Dialog -->
	<div id="ai-modal" class="modal-overlay">
		<div class="modal-dialog">
			<div class="modal-header">AI Assistant</div>
			<div class="modal-body">
				<div class="modal-field">
					<label for="ai-password-input">Password:</label>
					<input type="text" id="ai-password-input" placeholder="Enter password">
				</div>
				<div class="modal-field">
					<label for="ai-language-select">Language:</label>
					<select id="ai-language-select">
						<option value="English">English</option>
						<option value="ƒåesky">ƒåesky</option>
					</select>
				</div>
				<div class="modal-field">
					<label for="ai-prompt-input">Instructions:</label>
					<textarea id="ai-prompt-input" placeholder="What would you like the AI to do?" style="width: 100%; min-height: 100px; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; font-family: inherit; resize: vertical;"></textarea>
				</div>
				<div id="ai-status" class="modal-status"></div>
			</div>
			<div class="modal-footer">
				<button id="ai-cancel-btn" class="modal-btn modal-btn-secondary">Cancel</button>
				<button id="ai-submit-btn" class="modal-btn modal-btn-primary">Generate</button>
			</div>
		</div>
	</div>

	<!-- Fullscreen Preview -->
	<div id="fullscreen-container" class="fullscreen-preview">
		<button id="fullscreen-close-btn" class="fullscreen-close-btn" title="Close fullscreen">√ó</button>
		<iframe id="fullscreen-frame" src="about:blank"></iframe>
	</div>

	<!-- Monaco Editor -->
	<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.54.0/min/vs/loader.js"></script>

	<script>
		console.log('JavaScript is running!')

		class JSEasyIDE {
			constructor() {
				this.editor = null
				this.currentCode = ''
				this.isUpdating = false
				this.updateTimeout = null
				this.storageKey = 'js-easy-editor-content'
				this.eslint = null

				this.init()
			}

			async init() {
				await this.initMonaco()
				this.setupEventListeners()

				// Check for URL parameters to load a file
				const loadedFromURL = await this.checkURLParameters()

				// Only load default code if we didn't load from URL
				if (!loadedFromURL) {
					this.loadDefaultCode()
				}

				this.initESLint()
			}

			async initMonaco() {
				return new Promise((resolve) => {
					require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.54.0/min/vs' }})
					require(['vs/editor/editor.main'], () => {
						this.editor = monaco.editor.create(document.getElementById('monaco-editor'), {
							value: '',
							language: 'html',
							theme: 'vs',
							automaticLayout: true,
							minimap: { enabled: false },
							scrollBeyondLastLine: false,
							fontSize: 14,
							lineNumbers: 'on',
							wordWrap: 'off',
							folding: true,
							lineDecorationsWidth: 10,
							lineNumbersMinChars: 3,
							renderLineHighlight: 'line',
							cursorStyle: 'line',
							selectOnLineNumbers: true,
							roundedSelection: false,
							readOnly: false,
							contextmenu: true,
							mouseWheelZoom: true,
							quickSuggestions: true,
							suggestOnTriggerCharacters: true,
							acceptSuggestionOnEnter: 'on',
							tabCompletion: 'on',
							wordBasedSuggestions: 'off',
							glyphMargin: true,
							lightbulb: { enabled: true }
						})

						// Listen for content changes
						this.editor.onDidChangeModelContent(() => {
							this.debouncedUpdate()
						})

						resolve()
					})
				})
			}

			initESLint() {
				try {
					// Initialize ESLint linter
					if (typeof eslint !== 'undefined' && eslint.Linter) {
						this.eslint = new eslint.Linter()
						console.log('ESLint initialized successfully')
					} else {
						console.warn('ESLint not available - check browser console for loading issues')
					}
				} catch (error) {
					console.error('Failed to initialize ESLint:', error)
				}
			}

			async checkURLParameters() {
				try {
					// Get URL parameters
					const urlParams = new URLSearchParams(window.location.search)
					const fileName = urlParams.get('load')

					if (!fileName) {
						return false // No load parameter found
					}

					console.log('Loading file from URL parameter:', fileName)
					this.updateStatus('loading', `Loading ${fileName}...`)

					// Fetch the file from the server
					const response = await fetch(`/list?file=${encodeURIComponent(fileName)}`)

					if (!response.ok) {
						throw new Error(`Failed to load file: ${response.status} ${response.statusText}`)
					}

					const content = await response.text()

					// Load the content into the editor
					this.editor.setValue(content)

					// Fold the <head> section if it exists
					setTimeout(() => {
						this.foldHeadSection()
					}, 500)

					// Update preview
					this.updatePreview()

					// Remove the parameter from the URL without reloading the page
					const newURL = window.location.pathname + window.location.hash
					window.history.replaceState({}, document.title, newURL)

					this.updateStatus('success', `Loaded ${fileName}`)
					console.log('File loaded successfully from URL parameter')

					// Reset status to Ready after 2 seconds
					setTimeout(() => {
						this.updateStatus('success', 'Ready')
					}, 2000)

					return true // Successfully loaded from URL

				} catch (error) {
					console.error('Error loading file from URL parameter:', error)
					this.updateStatus('error', `Failed to load file: ${error.message}`)

					// Reset status to Ready after 3 seconds
					setTimeout(() => {
						this.updateStatus('success', 'Ready')
					}, 3000)

					// Remove the parameter from the URL even if loading failed
					const newURL = window.location.pathname + window.location.hash
					window.history.replaceState({}, document.title, newURL)

					return false // Failed to load from URL
				}
			}

			setupEventListeners() {
				// Toolbar buttons
				document.getElementById('send-btn').addEventListener('click', () => this.showSendDialog())
				document.getElementById('fullscreen-btn').addEventListener('click', () => this.showFullscreen())
				document.getElementById('list-btn').addEventListener('click', () => this.showList())
				document.getElementById('chat-btn').addEventListener('click', () => this.showChat())
				document.getElementById('ai-btn').addEventListener('click', () => this.showAIDialog())
				document.getElementById('new-btn').addEventListener('click', () => this.newFile())
				document.getElementById('load-btn').addEventListener('click', () => this.loadFile())
				document.getElementById('save-btn').addEventListener('click', () => this.saveFile())
				document.getElementById('undo-btn').addEventListener('click', () => this.undo())
				document.getElementById('redo-btn').addEventListener('click', () => this.redo())
				document.getElementById('copy-btn').addEventListener('click', () => this.copy())
				document.getElementById('paste-btn').addEventListener('click', () => this.paste())
				document.getElementById('clear-storage-btn').addEventListener('click', () => this.clearStorage())
				document.getElementById('image-upload-btn').addEventListener('click', () => this.uploadImage())

				// Setup GitHub example select (assumes <select id="github-example-select"> is in the toolbar in HTML)
				const githubSelect = document.getElementById('github-example-select')
				if (githubSelect) {
					// Add options 1-10 dynamically
					const defaultOption = document.createElement('option')
					defaultOption.value = ''
					defaultOption.textContent = 'Load'
					githubSelect.appendChild(defaultOption)
					for (let i = 3; i <= 20; i++) {
						const opt = document.createElement('option')
						const file = `${i.toString().padStart(2, '0')}/index.html`
						opt.value = file
						opt.textContent = file
						githubSelect.appendChild(opt)
					}

					const customFiles = [
						'------------------',
						'01/house-colored.html',
						'06/index-after.html',
						'students/vasik-06.html',
					]

					for (const file of customFiles) {
						const opt = document.createElement('option')
						opt.value = file
						opt.textContent = file
						githubSelect.appendChild(opt)
					}


					githubSelect.addEventListener('change', async (e) => {
						const val = e.target.value
						if (!val) return
						const url = `https://raw.githubusercontent.com/vaclav-purchart/js-easy/refs/heads/main/${val}`
						console.log('fetching', url)
						const previewFrame = document.getElementById('preview-frame')

						if (previewFrame && typeof previewFrame.focus === "function") {
							previewFrame.focus()
						}

						try {
							const resp = await fetch(url)
							if (!resp.ok) {
								alert('Failed to fetch example: ' + resp.status)
								return
							}
							const text = await resp.text()
							// Set content to editor (assumes Monaco)
							if (this.editor && typeof this.editor.setValue === 'function') {
								this.editor.setValue(text)
							} else {
								// fallback: try to set to textarea with id 'editor'
								const ta = document.getElementById('editor')
								if (ta) ta.value = text
							}
							setTimeout(() => {
								this.foldHeadSection()
							}, 500)

						} catch (err) {
							alert('Error fetching example: ' + err)
						}
						// Reset select to default
						githubSelect.value = ''
					})
				}

				// File input
				document.getElementById('file-input').addEventListener('change', (e) => this.handleFileLoad(e))

				// Image input
				document.getElementById('image-input').addEventListener('change', (e) => this.handleImageUpload(e))

				// Send modal buttons
				document.getElementById('send-cancel-btn').addEventListener('click', () => this.closeSendDialog())
				document.getElementById('send-submit-btn').addEventListener('click', () => this.sendToServer())

				// AI modal buttons
				document.getElementById('ai-cancel-btn').addEventListener('click', () => this.closeAIDialog())
				document.getElementById('ai-submit-btn').addEventListener('click', () => this.sendToAI())

				// Fullscreen close button
				document.getElementById('fullscreen-close-btn').addEventListener('click', () => this.closeFullscreen())

				// Close modal on overlay click
				document.getElementById('send-modal').addEventListener('click', (e) => {
					if (e.target.id === 'send-modal') {
						this.closeSendDialog()
					}
				})
				document.getElementById('ai-modal').addEventListener('click', (e) => {
					if (e.target.id === 'ai-modal') {
						this.closeAIDialog()
					}
				})

				// Handle Enter key in modal inputs
				const userNameInput = document.getElementById('user-name-input')
				const projectNameInput = document.getElementById('project-name-input')
				userNameInput.addEventListener('keypress', (e) => {
					if (e.key === 'Enter') {
						projectNameInput.focus()
					}
				})
				projectNameInput.addEventListener('keypress', (e) => {
					if (e.key === 'Enter') {
						this.sendToServer()
					}
				})

				// Handle Ctrl+Enter in AI prompt textarea
				const aiPromptInput = document.getElementById('ai-prompt-input')
				aiPromptInput.addEventListener('keydown', (e) => {
					if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
						e.preventDefault()
						this.sendToAI()
					}
				})

				// Keyboard shortcuts
				document.addEventListener('keydown', (e) => {
					if (e.ctrlKey || e.metaKey) {
						switch(e.key) {
							case 's':
								e.preventDefault()
								this.saveFile()
								break
							case 'o':
								e.preventDefault()
								this.loadFile()
								break
							case 'n':
								e.preventDefault()
								this.newFile()
								break
						}
					}
				})
			}

			loadDefaultCode() {
				// Check if there's saved content in localStorage
				const savedCode = this.loadFromLocalStorage()

				if (savedCode) {
					console.log('Loading saved content from localStorage')
					this.editor.setValue(savedCode)
				} else {
					console.log('Loading default code')
					const defaultCode = `<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Canvas Demo</title>
	<style>
		canvas {
			border: 2px solid #333;
			border-radius: 10px;
			margin: 20px 0;
		}
	</style>
	</head>
<body>
<canvas id="myCanvas" width="500" height="500"></canvas>
<script>

const canvas = document.getElementById("myCanvas")
const ctx = canvas.getContext("2d")

let x, y, sirka, vyska, polomer, x2, y2

// --------------------------------------------
// rectangle
// --------------------------------------------
x = 150
y = 100
sirka = 100
vyska = 100

ctx.fillStyle = "blue"
ctx.fillRect(x, y, sirka, vyska) // vybarveni

ctx.strokeStyle = "black"
ctx.lineWidth = 3
ctx.strokeRect(x, y, sirka, vyska) // okraj

// --------------------------------------------
// circle
// --------------------------------------------
x = 300
y = 300
polomer = 50

ctx.beginPath()
ctx.arc(x, y, polomer, 0, 2 * Math.PI)
ctx.fillStyle = "red"
ctx.fill() // vybarveni

ctx.strokeStyle = "purple"
ctx.lineWidth = 3
ctx.stroke() // okraj

// --------------------------------------------
// line
// --------------------------------------------
x = 100
y = 300
x2 = 200
y2 = 350

ctx.lineWidth = 5
ctx.strokeStyle = "green"

ctx.beginPath()
ctx.moveTo(x, y)
ctx.lineTo(x2, y2)
ctx.stroke()

// --------------------------------------------
// text
// --------------------------------------------
x = 50
y = 450
ctx.fillStyle = "gray"
ctx.font = "50px sans-serif"
ctx.fillText("Programujeme! :-)", x, y)

console.log("test")

<` + `/script>
</body>
</html>`

					this.editor.setValue(defaultCode)
				}

				// Fold the <head> section by default
				setTimeout(() => {
					this.foldHeadSection()
				}, 500)

				this.updatePreview()
			}

			foldHeadSection() {
				try {
					const model = this.editor.getModel()
					if (!model) return

					// Find the <head> tag and its closing </head> tag
					const text = model.getValue()
					const headStartMatch = text.match(/<head[^>]*>/i)
					const headEndMatch = text.match(/<\/head>/i)

					if (headStartMatch && headEndMatch) {
						const headStartIndex = headStartMatch.index
						const headEndIndex = headEndMatch.index + headEndMatch[0].length

						// Convert character positions to line numbers
						const headStartLine = model.getPositionAt(headStartIndex).lineNumber
						const headEndLine = model.getPositionAt(headEndIndex).lineNumber

						console.log('Folding head section from line', headStartLine, 'to line', headEndLine)

						// Try a different approach - use the editor's built-in folding
						// First, move cursor to the start of the head section
						this.editor.setPosition({ lineNumber: headStartLine, column: 1 })

						// Then try to fold the current block
						setTimeout(() => {
							this.editor.trigger('keyboard', 'editor.fold', null)
						}, 50)

						// Move cursor back to top
						setTimeout(() => {
							this.editor.setPosition({ lineNumber: 1, column: 1 })
						}, 100)
					}
				} catch (error) {
					console.error('Error folding head section:', error)
				}
			}

			debouncedUpdate() {
				if (this.updateTimeout) {
					clearTimeout(this.updateTimeout)
				}

				this.updateTimeout = setTimeout(() => {
					this.updatePreview()
					this.saveToLocalStorage() // Auto-save to localStorage
					this.checkJavaScriptErrors() // Simple syntax checking
					this.checkESLint() // ESLint checking (if available)
				}, 300)
			}

			updatePreview() {
				if (this.isUpdating) return

				this.isUpdating = true
				this.updateStatus('loading', 'Updating...')

				try {
					const code = this.editor.getValue()
					this.currentCode = code

					// Check for basic syntax errors in JavaScript
					const syntaxError = this.checkSyntaxErrors(code)
					if (syntaxError) {
						this.showError(syntaxError)
						this.updateStatus('error', 'Syntax error')
						this.isUpdating = false
						return
					}

					// Create a blob URL for the HTML content
					const blob = new Blob([code], { type: 'text/html' })
					const url = URL.createObjectURL(blob)

					const iframe = document.getElementById('preview-frame')
					const errorMessage = document.getElementById('error-message')

					// Hide error message initially
					errorMessage.classList.add('hidden')

					// Store original error handler
					const originalOnError = window.onerror

					// Set up error handling for the iframe
					iframe.onload = () => {
						try {
							// Set up error handling within the iframe
							const iframeWindow = iframe.contentWindow
							if (iframeWindow) {
								// Set up error handler for the iframe
								iframeWindow.onerror = (message, source, lineno, colno, error) => {
									console.log('Iframe error caught:', { message, source, lineno, colno, error })

									const errorMsg = `Runtime Error: ${message}`
									console.error('IDE Runtime Error:', errorMsg, {
										source,
										lineno,
										colno,
										error
									})
									this.showError(errorMsg)
									this.updateStatus('error', 'Runtime error')
									return true
								}

								// Set up promise rejection handler
								iframeWindow.addEventListener('unhandledrejection', (event) => {
									const errorMsg = `Promise Rejection: ${event.reason}`
									console.error('IDE Promise Error:', errorMsg, event)
									this.showError(errorMsg)
									this.updateStatus('error', 'Promise rejection')
								})

								// Set up a timeout to check for errors that might not be caught immediately
								setTimeout(() => {
									try {
										// Check if there are any obvious errors in the content
										const iframeDoc = iframe.contentDocument || iframe.contentWindow.document
										if (iframeDoc && iframeDoc.body) {
											// Look for JavaScript errors in the console or DOM
											if (iframeDoc.body.innerHTML.includes('error') ||
												iframeDoc.body.innerHTML.includes('Error') ||
												iframeDoc.body.innerHTML.includes('SyntaxError') ||
												iframeDoc.body.innerHTML.includes('ReferenceError') ||
												iframeDoc.body.innerHTML.includes('TypeError')) {
												console.error('IDE Content Error:', 'Content error detected')
												this.showError('Content error detected')
												this.updateStatus('error', 'Content error')
											} else {
												this.updateStatus('success', 'Ready')
												document.getElementById('preview-status-indicator').className = 'status-indicator status-success'
											}
										} else {
											this.updateStatus('success', 'Ready')
											document.getElementById('preview-status-indicator').className = 'status-indicator status-success'
										}
									} catch (e) {
										// Cross-origin or other errors - assume success
										console.log('Cross-origin error in iframe check:', e.message)
										this.updateStatus('success', 'Ready')
										document.getElementById('preview-status-indicator').className = 'status-indicator status-success'
									}
								}, 100)

								// Also set up a longer timeout to catch delayed errors
								setTimeout(() => {
									try {
										const iframeDoc = iframe.contentDocument || iframe.contentWindow.document
										if (iframeDoc && iframeDoc.body) {
											// Check for any error messages that might have appeared
											const bodyText = iframeDoc.body.textContent || iframeDoc.body.innerText || ''
											if (bodyText.includes('error') || bodyText.includes('Error') ||
												bodyText.includes('SyntaxError') || bodyText.includes('ReferenceError')) {
												console.error('IDE Delayed Error:', 'Delayed error detected')
												this.showError('Delayed error detected')
												this.updateStatus('error', 'Delayed error')
											}
										}
									} catch (e) {
										// Cross-origin or other errors - ignore
									}
								}, 500)
							} else {
								this.updateStatus('success', 'Ready')
								document.getElementById('preview-status-indicator').className = 'status-indicator status-success'
							}

							// Clean up the blob URL
							URL.revokeObjectURL(url)
						} catch (e) {
							// Cross-origin or other errors
							console.error('IDE Iframe Error:', e.message, e)
							this.updateStatus('success', 'Ready')
							document.getElementById('preview-status-indicator').className = 'status-indicator status-success'
							URL.revokeObjectURL(url)
						}

						this.isUpdating = false
					}

					iframe.onerror = () => {
						console.error('IDE Load Error:', 'Failed to load preview')
						this.showError('Failed to load preview')
						this.updateStatus('error', 'Load failed')
						this.isUpdating = false
						URL.revokeObjectURL(url)
					}

					// Set the iframe source
					iframe.src = url

				} catch (error) {
					console.error('IDE Update Error:', error.message, error)
					this.showError('Error updating preview: ' + error.message)
					this.updateStatus('error', 'Update failed')
					this.isUpdating = false
				}
			}

			checkJavaScriptErrors() {
				try {
					const code = this.editor.getValue()
					const model = this.editor.getModel()
					const markers = []

					// Extract JavaScript from script tags
					const scriptRegex = /<script[^>]*>([\s\S]*?)<\/script>/gi
					let match

					while ((match = scriptRegex.exec(code)) !== null) {
						const scriptContent = match[1]
						const scriptStartIndex = match.index + match[0].indexOf('>') + 1

						if (!scriptContent.trim()) continue

						// Try to parse the script to find syntax errors
						try {
							// Use Function constructor to check for syntax errors
							new Function(scriptContent)
						} catch (error) {
							// The error is caught, now we need to find where it is
							// We'll parse the error message and try to locate it in the script
							const errorMessage = error.message

							// Try to find the problematic token in the error message
							let problematicToken = null
							const tokenMatch = errorMessage.match(/Unexpected (token |identifier |string |number |end of input)?'?([^']+)'?/i)
							if (tokenMatch) {
								problematicToken = tokenMatch[2]
							}

							console.log('Syntax error:', errorMessage, 'Token:', problematicToken)

							// Search for the token in the script to find its position
							let errorLineIndex = 0
							let errorColumnIndex = 0
							let found = false

							if (problematicToken) {
								const scriptLines = scriptContent.split('\n')
								for (let i = 0; i < scriptLines.length; i++) {
									const index = scriptLines[i].indexOf(problematicToken)
									if (index !== -1) {
										errorLineIndex = i
										errorColumnIndex = index
										found = true
										console.log('Found error at line', i + 1, 'column', index + 1)
										break
									}
								}
							}

							// If we couldn't find the exact position, try to use eval with better error reporting
							if (!found) {
								try {
									// This will give us better error information
									eval(scriptContent)
								} catch (evalError) {
									// Still might not get line numbers, but worth a try
									console.log('Eval error:', evalError)
								}
								// Default to first line
								errorLineIndex = 0
								errorColumnIndex = 0
							}

							// Calculate the absolute position in the document
							const scriptLines = scriptContent.split('\n')
							let charOffset = 0
							for (let i = 0; i < errorLineIndex && i < scriptLines.length; i++) {
								charOffset += scriptLines[i].length + 1
							}
							charOffset += errorColumnIndex

							const errorPos = model.getPositionAt(scriptStartIndex + charOffset)

							// Calculate end position (highlight the token)
							let endOffset = charOffset
							if (problematicToken) {
								endOffset = charOffset + problematicToken.length
							} else {
								endOffset = charOffset + 1
							}
							const endPos = model.getPositionAt(scriptStartIndex + endOffset)

							markers.push({
								severity: monaco.MarkerSeverity.Error,
								startLineNumber: errorPos.lineNumber,
								startColumn: errorPos.column,
								endLineNumber: endPos.lineNumber,
								endColumn: endPos.column,
								message: `Syntax Error: ${errorMessage}`,
								source: 'JavaScript'
							})

							console.log('Marker created at line', errorPos.lineNumber, 'column', errorPos.column)
						}

						// Check for common runtime errors using simple pattern matching
						this.checkCommonErrors(scriptContent, scriptStartIndex, model, markers)
					}

					// Set markers on the model
					monaco.editor.setModelMarkers(model, 'javascript-errors', markers)

					// Verify markers were set
					const allMarkers = monaco.editor.getModelMarkers({ resource: model.uri })
					console.log(`Found ${markers.length} JavaScript issue(s)`)
					console.log('All markers on model:', allMarkers)
					console.log('Markers we just set:', markers)

				} catch (error) {
					console.error('Error checking JavaScript:', error)
				}
			}

			checkCommonErrors(scriptContent, scriptStartIndex, model, markers) {
				const lines = scriptContent.split('\n')

				lines.forEach((line, index) => {
					// Check for undefined variables (simple heuristic)
					// This is a basic check - not as comprehensive as ESLint
					const trimmedLine = line.trim()

					// Check for missing semicolons (only warn for certain statements)
					// if (trimmedLine.match(/^(let|const|var)\s+\w+\s*=\s*.+[^;{}\s]$/) && !trimmedLine.includes('//')) {
					// 	const lineStartOffset = lines.slice(0, index).reduce((sum, l) => sum + l.length + 1, 0)
					// 	const pos = model.getPositionAt(scriptStartIndex + lineStartOffset)
					// 	const endPos = model.getPositionAt(scriptStartIndex + lineStartOffset + line.length)

					// 	markers.push({
					// 		severity: monaco.MarkerSeverity.Warning,
					// 		startLineNumber: pos.lineNumber,
					// 		startColumn: pos.column,
					// 		endLineNumber: endPos.lineNumber,
					// 		endColumn: endPos.column,
					// 		message: 'Missing semicolon',
					// 		source: 'JavaScript'
					// 	})
					// }

					// Check for console.log statements (just for demonstration)
					// You can remove this if you don't want warnings for console.log
					/*
					if (trimmedLine.includes('console.log') && !trimmedLine.includes('//')) {
						const lineStartOffset = lines.slice(0, index).reduce((sum, l) => sum + l.length + 1, 0)
						const consolePos = line.indexOf('console.log')
						const pos = model.getPositionAt(scriptStartIndex + lineStartOffset + consolePos)
						const endPos = model.getPositionAt(scriptStartIndex + lineStartOffset + consolePos + 11)

						markers.push({
							severity: monaco.MarkerSeverity.Information,
							startLineNumber: pos.lineNumber,
							startColumn: pos.column,
							endLineNumber: endPos.lineNumber,
							endColumn: endPos.column,
							message: 'Unexpected console statement',
							source: 'JavaScript'
						})
					}
					*/
				})
			}

			checkESLint() {
				if (!this.eslint) {
					console.log('ESLint not available for checking')
					return
				}

				try {
					console.log('Running ESLint check...')
					const code = this.editor.getValue()
					const model = this.editor.getModel()

					// Extract JavaScript from script tags
					const scriptRegex = /<script[^>]*>([\s\S]*?)<\/script>/gi
					let match
					const markers = []

					while ((match = scriptRegex.exec(code)) !== null) {
						const scriptContent = match[1]
						const scriptStartIndex = match.index + match[0].indexOf('>') + 1

						if (!scriptContent.trim()) continue

						console.log('Found script block, linting...')

						try {
							// Run ESLint on the JavaScript code (using flat config format for ESLint 9.x)
							const messages = this.eslint.verify(scriptContent, {
								languageOptions: {
									ecmaVersion: 2022,
									sourceType: 'script',
									globals: {
										// Browser globals
										window: 'readonly',
										document: 'readonly',
										console: 'readonly',
										alert: 'readonly',
										setTimeout: 'readonly',
										setInterval: 'readonly',
										clearTimeout: 'readonly',
										clearInterval: 'readonly',
										fetch: 'readonly',
										localStorage: 'readonly',
										sessionStorage: 'readonly',
										navigator: 'readonly',
										location: 'readonly',
										history: 'readonly',
										// Common browser APIs
										Image: 'readonly',
										Audio: 'readonly',
										URL: 'readonly',
										Blob: 'readonly',
										FormData: 'readonly',
										XMLHttpRequest: 'readonly',
										// Canvas API
										CanvasRenderingContext2D: 'readonly',
										HTMLCanvasElement: 'readonly',
										// Math and other built-ins
										Math: 'readonly',
										Date: 'readonly',
										JSON: 'readonly',
										Promise: 'readonly',
										Array: 'readonly',
										Object: 'readonly',
										String: 'readonly',
										Number: 'readonly',
										Boolean: 'readonly',
										Function: 'readonly',
										Error: 'readonly',
										RegExp: 'readonly',
										Map: 'readonly',
										Set: 'readonly',
										WeakMap: 'readonly',
										WeakSet: 'readonly',
										Symbol: 'readonly',
										Proxy: 'readonly',
										Reflect: 'readonly',
										Intl: 'readonly',
										cancelAnimationFrame: 'readonly',
										requestAnimationFrame: 'readonly',
									}
								},
								rules: {
									'no-unused-vars': 'warn',
									'no-undef': 'error',
									'no-redeclare': 'error',
									'no-const-assign': 'error',
									'no-dupe-keys': 'error',
									'no-duplicate-case': 'error',
									'no-empty': 'warn',
									'no-extra-semi': 'warn',
									'no-func-assign': 'error',
									'no-unreachable': 'warn',
									'valid-typeof': 'error',
									'semi': 'off',
									'no-console': 'off'
								}
							})

							console.log('ESLint messages:', messages)

							// Convert ESLint messages to Monaco markers
							messages.forEach(msg => {
								// Calculate absolute position in the entire document
								const scriptStartPos = model.getPositionAt(scriptStartIndex)

								// Get the lines of script content up to the error line
								const scriptLines = scriptContent.split('\n')
								let charOffset = 0
								for (let i = 0; i < msg.line - 1; i++) {
									charOffset += scriptLines[i].length + 1 // +1 for newline
								}
								charOffset += msg.column - 1

								const errorPos = model.getPositionAt(scriptStartIndex + charOffset)

								// Calculate end position (try to highlight the whole word/token)
								let endColumn = msg.endColumn || msg.column
								const errorLineContent = scriptLines[msg.line - 1] || ''
								if (endColumn <= msg.column) {
									// If no end column, try to find the end of the current token
									const restOfLine = errorLineContent.substring(msg.column - 1)
									const tokenMatch = restOfLine.match(/^[a-zA-Z_$][a-zA-Z0-9_$]*/)
									if (tokenMatch) {
										endColumn = msg.column + tokenMatch[0].length
									} else {
										endColumn = msg.column + 1
									}
								}

								const endCharOffset = charOffset + (endColumn - msg.column)
								const endPos = model.getPositionAt(scriptStartIndex + endCharOffset)

								markers.push({
									severity: msg.severity === 2
										? monaco.MarkerSeverity.Error
										: monaco.MarkerSeverity.Warning,
									startLineNumber: errorPos.lineNumber,
									startColumn: errorPos.column,
									endLineNumber: endPos.lineNumber,
									endColumn: endPos.column,
									message: `${msg.message} (${msg.ruleId})`,
									source: 'ESLint'
								})

								console.log('ESLint marker:', {
									line: errorPos.lineNumber,
									column: errorPos.column,
									message: msg.message
								})
							})

						} catch (scriptError) {
							console.error('Error linting script block:', scriptError)
						}
					}

					// Set markers on the model
					monaco.editor.setModelMarkers(model, 'eslint', markers)

					console.log(`ESLint check complete. Found ${markers.length} issue(s)`)
					if (markers.length > 0) {
						console.log('ESLint markers:', markers)
					}

				} catch (error) {
					console.error('Error running ESLint:', error)
				}
			}

			checkSyntaxErrors(code) {
				try {
					// Extract JavaScript from script tags
					const scriptRegex = /<script[^>]*>([\s\S]*?)<\/script>/gi
					let match

					while ((match = scriptRegex.exec(code)) !== null) {
						const scriptContent = match[1]

						if (scriptContent.trim()) {
							// Check for syntax errors
							const syntaxError = this.checkScriptSyntax(scriptContent)
							if (syntaxError) {
								return syntaxError
							}
						}
					}

					return null
				} catch (error) {
					console.error('IDE Syntax Error:', error.message, error)
					return `Syntax Error: ${error.message}`
				}
			}

			checkScriptSyntax(scriptContent) {
				try {
					// First, try to parse the entire script to see if it's syntactically valid
					new Function(scriptContent)
					return null // No syntax errors found
				} catch (error) {
					console.error('IDE Syntax Error:', error.message, error)
					return `Syntax Error: ${error.message}`
				}
			}


			showError(message) {
				const errorMessage = document.getElementById('error-message')

				errorMessage.textContent = message
				errorMessage.classList.remove('hidden')

				this.updateStatus('error', 'Error')
				document.getElementById('preview-status-indicator').className = 'status-indicator status-error'
			}

			updateStatus(type, message) {
				const indicator = document.getElementById('status-indicator')
				const text = document.getElementById('status-text')

				indicator.className = `status-indicator status-${type}`
				text.textContent = message
			}

			newFile() {
				if (confirm('Are you sure you want to create a new file? Unsaved changes will be lost.')) {
					this.editor.setValue('')
					this.updatePreview()
				}
			}

			loadFile() {
				document.getElementById('file-input').click()
			}

			handleFileLoad(event) {
				const file = event.target.files[0]
				if (!file) return

				const reader = new FileReader()
				reader.onload = (e) => {
					this.editor.setValue(e.target.result)

					// Fold the <head> section if it exists
					setTimeout(() => {
						this.foldHeadSection()
					}, 100)

					this.updatePreview()
				}
				reader.readAsText(file)

				// Reset the input
				event.target.value = ''
			}

			saveFile() {
				const code = this.editor.getValue()
				const blob = new Blob([code], { type: 'text/html' })
				const url = URL.createObjectURL(blob)

				const a = document.createElement('a')
				a.href = url
				a.download = 'canvas-demo.html'
				document.body.appendChild(a)
				a.click()
				document.body.removeChild(a)

				URL.revokeObjectURL(url)
				this.updateStatus('success', 'File saved')

				setTimeout(() => {
					this.updateStatus('success', 'Ready')
				}, 2000)
			}

			// localStorage methods
			saveToLocalStorage() {
				try {
					const code = this.editor.getValue()
					localStorage.setItem(this.storageKey, code)
					console.log('Content saved to localStorage')
				} catch (error) {
					console.error('Error saving to localStorage:', error)
				}
			}

			loadFromLocalStorage() {
				try {
					const savedCode = localStorage.getItem(this.storageKey)
					if (savedCode) {
						console.log('Loading content from localStorage')
						return savedCode
					}
				} catch (error) {
					console.error('Error loading from localStorage:', error)
				}
				return null
			}

			clearLocalStorage() {
				try {
					localStorage.removeItem(this.storageKey)
					console.log('localStorage cleared')
				} catch (error) {
					console.error('Error clearing localStorage:', error)
				}
			}

			clearStorage() {
				if (confirm('Are you sure you want to clear all saved content? This will reset the editor to default code.')) {
					this.clearLocalStorage()
					this.loadDefaultCode()
					this.updateStatus('success', 'Storage cleared')

					setTimeout(() => {
						this.updateStatus('success', 'Ready')
					}, 2000)
				}
			}

			undo() {
				this.editor.trigger('keyboard', 'undo', null)
			}

			redo() {
				this.editor.trigger('keyboard', 'redo', null)
			}

			copy() {
				const selection = this.editor.getModel().getValueInRange(this.editor.getSelection())
				if (selection && selection.length > 0) {
					navigator.clipboard.writeText(selection)
					this.updateStatus('success', 'Selected text copied to clipboard')
				} else {
					this.updateStatus('error', 'No text selected')
				}
			}

			async paste() {
				try {
					const clipboardText = await navigator.clipboard.readText()

					if (clipboardText) {
						// Get current cursor position
						const position = this.editor.getPosition()

						// Insert the clipboard content at cursor position
						this.editor.executeEdits('paste', [{
							range: {
								startLineNumber: position.lineNumber,
								startColumn: position.column,
								endLineNumber: position.lineNumber,
								endColumn: position.column
							},
							text: clipboardText,
							forceMoveMarkers: true
						}])

						this.updateStatus('success', 'Content pasted')

						setTimeout(() => {
							this.updateStatus('success', 'Ready')
						}, 2000)
					} else {
						this.updateStatus('error', 'No content in clipboard')

						setTimeout(() => {
							this.updateStatus('success', 'Ready')
						}, 2000)
					}
				} catch (error) {
					console.error('Error pasting content:', error)
					this.updateStatus('error', 'Failed to paste content')

					setTimeout(() => {
						this.updateStatus('success', 'Ready')
					}, 2000)
				}
			}

			uploadImage() {
				document.getElementById('image-input').click()
			}

			handleImageUpload(event) {
				const file = event.target.files[0]
				if (!file) return

				// Check if it's an image file
				if (!file.type.startsWith('image/')) {
					alert('Please select an image file')
					return
				}

				// Check file size (limit to 10MB)
				if (file.size > 10 * 1024 * 1024) {
					alert('Image file is too large. Please select an image smaller than 5MB.')
					return
				}

				const reader = new FileReader()
				reader.onload = (e) => {
					const base64Data = e.target.result
					alert(`Base64 Data URL:\n\n${base64Data}`)
					// Try to copy Base64 data to clipboard
					if (navigator.clipboard && window.isSecureContext) {
						navigator.clipboard.writeText(`"${base64Data}"`).then(() => {
							this.updateStatus('success', 'Image base64 copied to clipboard')
						}).catch((err) => {
							this.updateStatus('error', 'Failed to copy base64 to clipboard')
							console.error('Clipboard copy failed:', err)
						})
					} else {
						// fallback for older browsers or non-secure context
						const textarea = document.createElement('textarea')
						textarea.value = `"${base64Data}"`
						textarea.style.position = 'fixed'
						textarea.style.top = '-1000px'
						document.body.appendChild(textarea)
						textarea.focus()
						textarea.select()
						try {
							document.execCommand('copy')
							this.updateStatus('success', 'Image base64 copied to clipboard')
						} catch (err) {
							this.updateStatus('error', 'Failed to copy base64 to clipboard')
							console.error('Clipboard fallback copy failed:', err)
						}
						document.body.removeChild(textarea)
					}
					this.updateStatus('success', 'Image uploaded successfully')

					setTimeout(() => {
						this.updateStatus('success', 'Ready')
					}, 2000)
				}
				reader.readAsDataURL(file)

				// Reset the input
				event.target.value = ''
			}

			// Send Dialog Methods
			showSendDialog() {
				const modal = document.getElementById('send-modal')
				const userNameInput = document.getElementById('user-name-input')
				const projectNameInput = document.getElementById('project-name-input')
				const statusDiv = document.getElementById('send-status')

				// Load saved values from localStorage
				const savedUserName = localStorage.getItem('js-easy-user-name') || ''
				const savedProjectName = localStorage.getItem('js-easy-project-name') || ''

				userNameInput.value = savedUserName
				projectNameInput.value = savedProjectName

				// Clear status
				statusDiv.className = 'modal-status'
				statusDiv.textContent = ''

				// Show modal
				modal.classList.add('active')

				// Focus on first empty field or user name
				if (!savedUserName) {
					userNameInput.focus()
				} else if (!savedProjectName) {
					projectNameInput.focus()
				} else {
					userNameInput.focus()
				}
			}

			showList() {
				window.open('https://purchart.cloud/list', '_blank')
			}

			showChat() {
				window.open('https://purchart.cloud/chat', '_blank')
			}

			// Fullscreen Methods
			showFullscreen() {
				const code = this.editor.getValue()
				const fullscreenContainer = document.getElementById('fullscreen-container')
				const fullscreenFrame = document.getElementById('fullscreen-frame')

				// Create a blob URL for the HTML content
				const blob = new Blob([code], { type: 'text/html' })
				const url = URL.createObjectURL(blob)

				// Set the iframe source
				fullscreenFrame.src = url

				// Show fullscreen container
				fullscreenContainer.classList.add('active')

				// Clean up the blob URL after loading
				fullscreenFrame.onload = () => {
					URL.revokeObjectURL(url)
				}
			}

			closeFullscreen() {
				const fullscreenContainer = document.getElementById('fullscreen-container')
				const fullscreenFrame = document.getElementById('fullscreen-frame')

				// Hide fullscreen container
				fullscreenContainer.classList.remove('active')

				// Clear the iframe to stop any running scripts
				fullscreenFrame.src = 'about:blank'
			}

			closeSendDialog() {
				const modal = document.getElementById('send-modal')
				modal.classList.remove('active')
			}

			async sendToServer() {
				const userNameInput = document.getElementById('user-name-input')
				const projectNameInput = document.getElementById('project-name-input')
				const submitBtn = document.getElementById('send-submit-btn')
				const statusDiv = document.getElementById('send-status')

				const userName = userNameInput.value.trim()
				const projectName = projectNameInput.value.trim()

				// Validate inputs
				if (!userName) {
					statusDiv.className = 'modal-status error'
					statusDiv.textContent = 'Please enter your user name'
					userNameInput.focus()
					return
				}

				if (!projectName) {
					statusDiv.className = 'modal-status error'
					statusDiv.textContent = 'Please enter a project name'
					projectNameInput.focus()
					return
				}

				// Save to localStorage
				localStorage.setItem('js-easy-user-name', userName)
				localStorage.setItem('js-easy-project-name', projectName)

				// Get editor content
				const code = this.editor.getValue()

				// Show sending state
				statusDiv.className = 'modal-status sending'
				statusDiv.textContent = 'Sending...'
				submitBtn.disabled = true

				try {
					// Send to server
					const response = await fetch('/api/send', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json'
						},
						body: JSON.stringify({
							userName: userName,
							projectName: projectName,
							code: code
						})
					})

					if (response.ok) {
						const data = await response.json()

						if (data.result === 'ok') {
							// Success
							statusDiv.className = 'modal-status success'
							statusDiv.textContent = 'Successfully sent to server!'

							// Update main status
							this.updateStatus('success', 'Project sent successfully')

							// Close dialog after 2 seconds
							setTimeout(() => {
								this.closeSendDialog()
								this.updateStatus('success', 'Ready')
								submitBtn.disabled = false
							}, 2000)
						} else {
							// Unexpected response
							statusDiv.className = 'modal-status error'
							statusDiv.textContent = 'Unexpected server response'
							submitBtn.disabled = false
						}
					} else {
						// HTTP error
						statusDiv.className = 'modal-status error'
						statusDiv.textContent = `Server error: ${response.status} ${response.statusText}`
						submitBtn.disabled = false
					}
				} catch (error) {
					// Network or other error
					console.error('Error sending to server:', error)
					statusDiv.className = 'modal-status error'
					statusDiv.textContent = `Error: ${error.message}`
					submitBtn.disabled = false
				}
			}

			// AI Dialog Methods
			showAIDialog() {
				const modal = document.getElementById('ai-modal')
				const passwordInput = document.getElementById('ai-password-input')
				const languageSelect = document.getElementById('ai-language-select')
				const promptInput = document.getElementById('ai-prompt-input')
				const statusDiv = document.getElementById('ai-status')

				// Load saved values from localStorage
				const savedPassword = localStorage.getItem('ai-password') || ''
				const savedLanguage = localStorage.getItem('ai-language') || 'English'

				passwordInput.value = savedPassword
				languageSelect.value = savedLanguage
				promptInput.value = ''

				// Clear status
				statusDiv.className = 'modal-status'
				statusDiv.textContent = ''

				// Show modal
				modal.classList.add('active')

				// Focus on prompt input
				promptInput.focus()
			}

			closeAIDialog() {
				const modal = document.getElementById('ai-modal')
				modal.classList.remove('active')
			}

			async sendToAI() {
				const passwordInput = document.getElementById('ai-password-input')
				const languageSelect = document.getElementById('ai-language-select')
				const promptInput = document.getElementById('ai-prompt-input')
				const submitBtn = document.getElementById('ai-submit-btn')
				const statusDiv = document.getElementById('ai-status')

				const password = passwordInput.value.trim()
				const language = languageSelect.value
				const prompt = promptInput.value.trim()

				// Validate inputs
				if (!password) {
					statusDiv.className = 'modal-status error'
					statusDiv.textContent = 'Please enter password'
					passwordInput.focus()
					return
				}

				if (!prompt) {
					statusDiv.className = 'modal-status error'
					statusDiv.textContent = 'Please enter instructions'
					promptInput.focus()
					return
				}

				// Save to localStorage
				localStorage.setItem('ai-password', password)
				localStorage.setItem('ai-language', language)

				// Get editor content
				const editorContent = this.editor.getValue()

				// Create message with context
				const message = `Here is the current code:\n\n${editorContent}\n\n${prompt}`

				// Show processing state
				statusDiv.className = 'modal-status sending'
				statusDiv.textContent = 'Processing...'
				submitBtn.disabled = true

				try {
					// Send to AI API
					const response = await fetch('/api/chat', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify({
							model: 'gpt-oss:20b',
							password,
							language,
							messages: [{ role: 'user', content: message }],
							stream: true,
						}),
					})

					if (!response.ok) {
						if (response.status === 403) {
							throw new Error('Invalid password. Please check your password and try again.')
						}
						if (response.status === 429) {
							const errorData = await response.json()
							const waitTime = errorData.retryAfter || 1
							throw new Error(`Rate limit exceeded. Please wait ${waitTime} second${waitTime > 1 ? 's' : ''} before trying again.`)
						}
						throw new Error(`HTTP error! status: ${response.status}`)
					}

					const reader = response.body.getReader()
					const decoder = new TextDecoder()
					let fullResponse = ''

					statusDiv.className = 'modal-status sending'
					statusDiv.textContent = 'Receiving response...'

					while (true) {
						const { done, value } = await reader.read()

						if (done) break

						const chunk = decoder.decode(value)
						const lines = chunk.split('\n').filter(line => line.trim())

						for (const line of lines) {
							try {
								const json = JSON.parse(line)
								if (json.message && json.message.content) {
									fullResponse += json.message.content
								}
							} catch (e) {
								// Skip invalid JSON lines
							}
						}
					}

					// Update editor with the response
					if (fullResponse) {
						// Extract code from markdown code blocks if present
						const codeBlockRegex = /```(?:html|javascript|js)?\s*\n([\s\S]*?)```/g
						const match = codeBlockRegex.exec(fullResponse)

						if (match && match[1]) {
							// Use the code from the first code block
							this.editor.setValue(match[1].trim())
						} else {
							// If no code block, use the entire response
							this.editor.setValue(fullResponse.trim())
						}

						this.updatePreview()

						// Success
						statusDiv.className = 'modal-status success'
						statusDiv.textContent = 'Code updated successfully!'

						// Update main status
						this.updateStatus('success', 'AI code generated')

						// Close dialog after 2 seconds
						setTimeout(() => {
							this.closeAIDialog()
							this.updateStatus('success', 'Ready')
							submitBtn.disabled = false
						}, 2000)
					} else {
						statusDiv.className = 'modal-status error'
						statusDiv.textContent = 'No response received from AI'
						submitBtn.disabled = false
					}

				} catch (error) {
					console.error('Error sending to AI:', error)
					statusDiv.className = 'modal-status error'
					statusDiv.textContent = `Error: ${error.message}`
					submitBtn.disabled = false
				}
			}
		}

		// Initialize the IDE when the page loads
		document.addEventListener('DOMContentLoaded', () => {
			new JSEasyIDE()
		})
	</script>
</body>
</html>

<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Pixel Art Editor</title>
	<style>
:root {
	--bg: #f3f3f3;
	--panel-bg: #fff;
	--accent: #0b84ff;
	--controls-width: 275px;
	--layers-width: 275px;
	--topbar-height: 48px;
}

* {
	box-sizing: border-box;
}

body {
	margin: 0;
	font-family: Inter, Arial, Helvetica, sans-serif;
	background: var(--bg);
	color: #111;
}

#topbar {
	display: flex;
	gap: 12px;
	align-items: center;
	padding: 8px 12px;
	background: var(--panel-bg);
	border-bottom: 1px solid #e0e0e0;
	box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
	position: sticky;
	top: 0;
	white-space: nowrap;
	overflow-x: auto;
	z-index: 10;
}

#app {
	display: flex;
	gap: 10px;
	flex: 1;
	padding: 10px;
	overflow: hidden;
}

.panel {
	background: var(--panel-bg);
	padding: 12px;
	border-radius: 8px;
	box-shadow: 0 6px 18px rgba(0, 0, 0, .06)
}

.controls {
	width: var(--controls-width);
	min-width: var(--controls-width);
	max-width: var(--controls-width);
	max-height: 100%;
	overflow-y: auto;
	overflow-x: hidden;
}

#showHideControls {
	position: absolute;
	left: calc(var(--controls-width) - 40px);
	top: calc(var(--topbar-height) + 20px);
	border: none;
}

#showHideLayers {
	position: absolute;
	right: 20px;
	top: calc(var(--topbar-height) + 20px);
	border: none;
}

.row {
	display: flex;
	gap: 8px;
	align-items: center;
	margin-bottom: 8px
}

.controls-section {
	margin-bottom: 16px;
}

label {
	font-size: 13px;
	min-width: 72px
}

input[type=number] {
	width: 80px;
	padding: 6px;
	border-radius: 6px;
	border: 1px solid #ccc
}

input[type=text] {
	width: 100%;
	padding: 6px;
	border-radius: 6px;
	border: 1px solid #ccc
}

button {
	padding: 6px 10px;
	border-radius: 6px;
	border: 1px solid #bbb;
	background: white;
	cursor: pointer;
	display: inline-flex;
	align-items: center;
	gap: 6px
}

.palette {
	display: flex;
	gap: 6px;
	flex-wrap: wrap
}

.palette button {
	width: 36px;
	height: 28px;
	padding: 0;
	border: 2px solid #ddd
}

.grid-wrap {
	background: linear-gradient(#fff, #eee);
	padding: 12px;
	border-radius: 8px
}

.preview {
	margin-top: 12px;
	border: 1px solid #ccc;
	display: inline-block
}

.small {
	font-size: 12px;
	color: #555
}

.toolbar {
	display: flex;
	gap: 8px;
	margin-top: 8px;
	margin-bottom: 8px;
	align-items: center
}

.tool-btn {
	border: 1px solid #ccc;
	padding: 6px 10px;
	border-radius: 6px;
	background: white;
	display: inline-flex;
	align-items: center;
	gap: 8px;
	cursor: pointer
}

.tool-btn.active {
	border-color: var(--accent);
	box-shadow: 0 4px 12px rgba(11, 132, 255, .12);
	background: linear-gradient(#fff, #f0fbff)
}

.preview-wrap {
	display: flex;
	gap: 12px;
	align-items: center;
	margin-top: 12px
}

.canvas-stage {
	position: relative;
	user-select: none;
	touch-action: none
}

#displayCanvas {
	background-image: repeating-conic-gradient(#ccc 0% 25%, #eee 0% 50%);
	background-size: 12px 12px;
	display: block
}

#overlayCanvas {
	position: absolute;
	left: 0;
	top: 0;
	pointer-events: none
}

/* layers panel */
.layers-panel {
	width: 275px
}

.layer-item {
	display: flex;
	gap: 8px;
	align-items: center;
	padding: 6px;
	border-radius: 6px;
	border: 1px solid #eee;
	margin-bottom: 6px;
	background: #fafafa
}

.layer-item.active {
	border-color: var(--accent);
	box-shadow: 0 6px 14px rgba(11, 132, 255, 0.08);
	cursor: crosshair;
}

.layer-thumb {
	width: 48px;
	height: 48px;
	border: 1px solid #ccc;
	background: #fff
}

.layer-controls {
	display: flex;
	gap: 6px;
	margin-left: auto
}

.align-sides {
	display: flex;
	justify-content: space-between;
}

/* selection handles */
.sel-handle {
	width: 8px;
	height: 8px;
	background: #fff;
	border: 1px solid #333;
	position: absolute;
	transform: translate(-50%, -50%);
}

.controls-footer {
	margin-top: 8px
}

.controls h3 {
	margin: 8px 0;
	font-size: 13px;
}

.canvas-panel {
	display: flex;
	flex-direction: column;
	padding: 12px;
	margin: auto;
	/* max-width: calc(100% - var(--controls-width) - var(--layers-width)); */
	max-height: calc(100vh - var(--topbar-height) - 24px);
	overflow: auto;
	margin-top: 0;
}

#pickerPreview {
	display: none;
	position: absolute;
	left: 0;
	top: 0;
	width: 40px;
	height: 40px;
	border: 3px dotted black;
	z-index: 20;
	border-radius: 10px;
}

/* not implemented yet */
.not-implemented-yet { display: none; }
	</style>
</head>

<body>
	<header id="topbar">
		<div id="tools" role="toolbar" aria-label="Tools">
			<button class="tool-btn" data-tool="pencil" id="toolPencil" title="Hotkey: P">‚úé Pencil</button>
			<button class="tool-btn" data-tool="fill" id="toolPicker" title="Hotkey: I">üëÜ Picker</button>
			<button class="tool-btn" data-tool="fill" id="toolFill" title="Hotkey: B">ü™£ Fill</button>
			<button class="tool-btn" data-tool="line" id="toolLine" title="Hotkey: L">‚ï± Line</button>
			<button class="tool-btn" data-tool="rect" id="toolRect" title="Hotkey: R">‚ñ≠ Rect</button>
			<button class="tool-btn" data-tool="ellipse" id="toolEllipse" title="Hotkey: E">‚óØ Ellipse</button>
			<button class="tool-btn" data-tool="select" id="toolSelect" title="Hotkey: A">‚ñ§ Select</button>
			<input type="checkbox" id="fillShapes" title="Fill shapes (rectangle, ellipse)" checked>
			<label for="fillShapes">Fill shapes</label>
		</div>

		<div class="small" style="opacity:0.8">Tool: <span id="toolLabel">Pencil</span></div>
		<div class="small" style="opacity:0.8"><span id="currentCursorInfo"></span></div>

		<div style="margin-left:auto;display:flex;gap:8px;align-items:center">
			<button id="undoBtn" class="tool-btn">‚Ü©Ô∏èUndo</button>
			<button id="redoBtn" class="tool-btn not-implemented-yet">Redo</button>
			<button id="confirmBtn" class="tool-btn" disabled title="Hotkey: Enter">‚úÖConfirm</button>
			<button id="cancelBtn" class="tool-btn" disabled title="Hotkey: Escape">‚ùåCancel</button>
			<button id="toggleLayers" class="tool-btn not-implemented-yet">Toggle Layers</button>
			<div style="width:1px;height:28px;background:#eee;margin:0 8px"></div>
			üîé
			<button id="zoomOut" class="tool-btn">‚àí</button>
			<div id="zoomVal" class="small">16</div>
			<button id="zoomIn" class="tool-btn">+</button>
		</div>
	</header>
	<button id="showHideControls">‚óÄÔ∏è</button>
	<button id="showHideLayers">‚óÄÔ∏è</button>
	<div id="app">
		<div class="panel controls" id="sidePanel-controls">
			<div class="controls-section">
				<h3>Image size</h3>

				<div class="row">
					<label for="width">Width</label>
					<input id="width" type="number" min="1" max="512" value="32">px
				</div>
				<div class="row">
					<label for="height">Height</label>
					<input id="height" type="number" min="1" max="512" value="32">px
				</div>
				<div class="row">
					<button id="applySize">Apply size</button>
				</div>
			</div>

			<div class="controls-section">
				<div class="row align-sides">
					<h3>Colors</h3>
					<button id="colorSwitch" title="Hotkey: O">‚áÑ Switch colors</button>
				</div>
				<div class="row">
					<label for="colorPicker">Primary</label>
					<input id="colorPicker" type="color" value="#ff0000">
					<div class="small">Primary: <span id="currentColor">#ff0000</span></div>
				</div>
				<div class="row">
					<label for="colorPicker2">Secondary</label>
					<input id="colorPicker2" type="color" value="#0000ff">
					<div class="small">Secondary: <span id="currentColor2">#0000ff</span></div>
				</div>
				<div class="row palette" id="palette"></div>
				<div class="row palette" id="imagePalette"></div>
			</div>

			<div class="controls-section">
				<h3>Actions</h3>
				<div class="row">
					<button id="clearBtn">üóëÔ∏èClear</button>
					<button id="copySelBtn">Copy</button>
					<button id="pasteSelBtn">Paste</button>
				</div>
			</div>

			<div class="controls-section">
				<h3>Import / Export</h3>
				<div class="row">
					<label for="fileInput">Load image:</label>
					<input type="file" id="fileInput" accept="image/png,image/*" />
				</div>
				<div style="margin-top:12px">
					<div class="small">Image data URL (updates on every change)</div>
					<input id="dataUrlInput" type="text">
					<div class="row" style="margin-top:8px">
						<button id="pasteBase64Btn">Load from base64</button>
					</div>
					<div class="row" style="margin-top:8px">
						<button id="copyUrlBtn">Copy URL</button>
						<button id="downloadBtn">Download PNG</button>
					</div>
				</div>
				<h3>Layers Import / Export</h3>
				<div class="row">
					<label for="layersFileInput">Load layers:</label>
					<input type="file" id="layersFileInput" accept="application/JSON" />
				</div>
				<div class="row">
					<button id="downloadLayersBtn">Download Layers</button>
				</div>
			</div>
			<div class="foot small" style="margin-top:8px">Tip: Right-click on the canvas to set the Secondary color.
				Selection and shapes require confirmation (Confirm button or Enter) to apply.</div>
			<div class="controls-section not-implemented-yet">
				<h3>Isometric helpers</h3>
				<div class="row">
					<label for="isoWidth">ISO width</label>
					<input id="isoWidth" type="number" min="1" max="512" value="32">px (1:2)
				</div>
				<div class="row">
					<button id="isoShowHide">Show/hide ISO grid</button>
				</div>
			</div>
		</div>

		<div class="panel canvas-panel">
			<div class="grid-wrap">
				<div class="canvas-stage" id="canvasStage">
					<canvas id="displayCanvas"></canvas>
					<canvas id="overlayCanvas"></canvas>
				</div>
			</div>
			<div class="preview-wrap">
				<div>
					<div>Preview (native resolution):</div>
					<canvas id="preview" class="preview"></canvas>
				</div>
			</div>
		</div>

		<div class="panel layers-panel" id="sidePanel-layers">
			<h3>Layers</h3>
			<div id="layersList"></div>
			<div style="display:flex;gap:8px;margin-top:8px">
				<button id="addLayer" title="Add new layer">‚ûï</button>
				<button id="deleteLayer" tooltip="Delete layer">üóëÔ∏è</button>
				<button id="moveUp" title="Move selected layer up">‚¨ÜÔ∏è</button>
				<button id="moveDown" title="Move selected layer down">‚¨áÔ∏è</button>
				<button id="mergeDown">Merge Down</button>
			</div>
		</div>
	</div>
	<div id="pickerPreview"></div>
<script type="module">

import { showNotification } from './notification.js'

// --- State ---
let width = 32,
	height = 32
let pixelSize = 16 // display pixels (zoom)
let primaryColor = "#ff0000"
let secondaryColor = "#0000ff"
let currentTool = "pencil" // 'pencil' | 'picker' | 'fill' | 'line' | 'rect' | 'ellipse' | 'select'
let showIsometricGrid = false
let toolBeforePicker = "pencil"

// layers: array of {name, pixels(array), visible:boolean}
let layers = []
let activeLayer = 0

let selection = null // {x,y,w,h, pixels:[], floating:boolean, offsetX,offsetY}
let clipboard = null
let floatingShape = null // {type,x,y,x2,y2,w,h,color}

const undoStack = []

const basicColors = [
	"transparent",
	"#000000",
	"#ffffff",
	"#ff0000",
	"#ffa07a",
	"#00ff00",
	"#0000ff",
	"#ffff00",
	"#ff00ff",
	"#00ffff",
	"#8b4513",
	"#808080",
]
// DOM
const displayCanvas = document.getElementById("displayCanvas")
const overlayCanvas = document.getElementById("overlayCanvas")
const preview = document.getElementById("preview")
const canvasStage = document.getElementById("canvasStage")
const display = document.getElementById("display")
const overlay = document.getElementById("overlay")
const stage = document.getElementById("stage")
const zoomVal = document.getElementById("zoomVal")
const pickerPreview = document.getElementById("pickerPreview")

const primaryPicker = document.getElementById("primaryColor")
const secondaryPicker = document.getElementById("secondaryColor")
const confirmBtn = document.getElementById("confirmBtn")
const cancelBtn = document.getElementById("cancelBtn")
const copySelBtn = document.getElementById("copySelBtn")
const pasteSelBtn = document.getElementById("pasteSelBtn")
const handleNames = ["nw", "n", "ne", "e", "se", "s", "sw", "w"]
let handles = []

function init() {
	// initialize single layer
	loadFromLocalStorage()
	layers = []
	addLayer("Layer 1")
	initPixelsForLayer(activeLayer)
	buildPalette()
	resizeCanvases()
	renderAll()
	attachEvents()
	updateToolUI()
	renderLayersUI()
	addImageColorsToCustomPalette()
}

function updateUIState() {
	confirmBtn.disabled = !(floatingShape || (selection && selection.floating))
	cancelBtn.disabled = !(floatingShape || selection)
	copySelBtn.disabled = !(selection != null)
	pasteSelBtn.disabled = !(clipboard != null)
	document.getElementById("undoBtn").disabled = undoStack.length === 0
	// document.getElementById("redoBtn").disabled = redoStack.length === 0
}

function saveToLocalStorage() {
	localStorage.setItem('pixelart_dataurl', document.getElementById('dataUrlInput').value)
	localStorage.setItem('pixelart_zoom', pixelSize)
	localStorage.setItem('pixelart_showIsometricGrid', showIsometricGrid)
	localStorage.setItem('pixelart_fillShapes', document.getElementById('fillShapes').checked)
}

function loadFromLocalStorage() {
	const zoom = localStorage.getItem('pixelart_zoom')
	if (zoom && zoom !== 'undefined') {
		document.getElementById('zoomVal').textContent = zoom
		pixelSize = Number(zoom)
	}
	const saved = localStorage.getItem('pixelart_dataurl')
	if (saved) loadBase64(saved)

	showIsometricGrid = localStorage.getItem('pixelart_showIsometricGrid')
	document.getElementById('fillShapes').checked = localStorage.getItem('pixelart_fillShapes') === 'true'

	resizeCanvases()
	renderAll()
	renderLayerThumbnails()
}

function setCurrentCursorInfo(x, y) {
	document.getElementById("currentCursorInfo").textContent = `[${x}, ${y}]`
	if (currentTool === 'picker') {
		pickerPreview.style.backgroundColor = getPixelFromComposite(x, y) || 'transparent'
		pickerPreview.style.display = 'block'
	}
}


function addLayer(name) {
	const pixels = new Array(width * height).fill(null)
	layers.push({
		name: name || `Layer ${layers.length + 1}`,
		pixels,
		visible: true,
	})
	activeLayer = layers.length - 1
	renderLayersUI()
}

function deleteLayer(index) {
	if (layers.length <= 1) return
	layers.splice(index, 1)
	activeLayer = Math.max(0, Math.min(activeLayer, layers.length - 1))
	renderLayersUI()
	renderAll()
}

function moveLayerUp(index) {
	if (index <= 0) return
	const a = layers.splice(index, 1)[0]
	layers.splice(index - 1, 0, a)
	activeLayer = index - 1
	renderLayersUI()
	renderAll()
}

function moveLayerDown(index) {
	if (index >= layers.length - 1) return
	const a = layers.splice(index, 1)[0]
	layers.splice(index + 1, 0, a)
	activeLayer = index + 1
	renderLayersUI()
	renderAll()
}

function initPixelsForLayer(idx) {
	layers[idx].pixels = new Array(width * height).fill(null)
}

function buildPalette() {
	const pal = document.getElementById("palette")
	pal.innerHTML = ""
	basicColors.forEach((c) => {
		const b = document.createElement("button")
		if (c === "transparent") b.style.background = "repeating-conic-gradient(#ccc 0% 25%, #eee 0% 50%) 50% / 6px 6px"
		else b.style.background = c
		b.addEventListener("click", () => setPrimary(c))
		pal.appendChild(b)
	})
}

function addImageColorsToCustomPalette() {
	const existingColors = new Set(basicColors)
	const newColors = new Set()

	// gather colors from all layers
	layers.forEach((layer) => {
		layer.pixels.forEach((c) => {
			if (c && !existingColors.has(c) && !newColors.has(c)) {
				newColors.add(c)
			}
		})
	})

	const pal = document.getElementById("imagePalette")
	pal.innerHTML = ""

	let index = 0
	newColors.forEach((c) => {
		if (index >= 24) return // limit number of colors in palette
		const b = document.createElement("button")
		b.style.background = c
		b.addEventListener("click", () => setPrimary(c))
		pal.appendChild(b)
		index++
	})

}

function setPrimary(hex) {
	if (hex.startsWith('rgb(')) {
		// convert rgb() to hex
		const rgb = hex.match(/\d+/g).map(Number)
		hex = '#' + rgb.map((v) => v.toString(16).padStart(2, '0')).join('')
	}
	primaryColor = hex
	document.getElementById("currentColor").textContent = hex
	if (hex !== "transparent") document.getElementById("colorPicker").value = hex
	document.getElementById("colorPicker").value = hex === "transparent" ? "#ffffff" : hex
}
function setSecondary(hex) {
	secondaryColor = hex
	document.getElementById("currentColor2").textContent = hex
	if (hex !== "transparent") document.getElementById("colorPicker2").value = hex
	document.getElementById("colorPicker2").value = hex === "transparent" ? "#ffffff" : hex
}

function drawRect(floatingShape, renderPixel) {
	const s = floatingShape
	for (let yy = 0; yy < s.h; yy++) {
		for (let xx = 0; xx < s.w; xx++) {
			const tx = s.x + xx
			const ty = s.y + yy
			if (s.fillShape) {
				renderPixel(tx, ty, s.color)
			}
			else {
				if (yy === 0 || yy === s.h - 1 || xx === 0 || xx === s.w - 1) {
					renderPixel(tx, ty, s.color)
				}
			}
		}
	}
}

function drawEllipse(floatingShape, renderPixel) {
	const s = floatingShape
	const rx = s.w / 2
	const ry = s.h / 2
	const cx = s.x + rx
	const cy = s.y + ry

	// precompute neighbor step in normalized ellipse coordinates
	const stepX = 1 / rx
	const stepY = 1 / ry

	for (let ty = Math.floor(s.y); ty < Math.ceil(s.y + s.h); ty++) {
		for (let tx = Math.floor(s.x); tx < Math.ceil(s.x + s.w); tx++) {
			const nx = (tx + 0.5 - cx) / rx
			const ny = (ty + 0.5 - cy) / ry
			const inside = nx * nx + ny * ny <= 1
			if (inside) {
				if (s.fillShape) {
					renderPixel(tx, ty, s.color)
				} else {
					// pixel is inside ellipse ‚Äî check 4-neighbour pixels;
					// if any neighbour is outside, this is a border pixel
					const leftOutside = ((nx - stepX) * (nx - stepX) + ny * ny) > 1
					const rightOutside = ((nx + stepX) * (nx + stepX) + ny * ny) > 1
					const upOutside = (nx * nx + (ny - stepY) * (ny - stepY)) > 1
					const downOutside = (nx * nx + (ny + stepY) * (ny + stepY)) > 1
					if (leftOutside || rightOutside || upOutside || downOutside) {
						renderPixel(tx, ty, s.color)
					}
				}
			}
		}
	}
}

function drawLine(floatingShape, renderPixel) {
	const startIdx = floatingShape.x + floatingShape.y * width
	const endIdx = floatingShape.x2 + floatingShape.y2 * width
	const color = floatingShape.color

	let x0 = startIdx % width
	let y0 = Math.floor(startIdx / width)
	const x1 = endIdx % width
	const y1 = Math.floor(endIdx / width)
	let dx = Math.abs(x1 - x0)
	let sx = x0 < x1 ? 1 : -1
	let dy = -Math.abs(y1 - y0)
	let sy = y0 < y1 ? 1 : -1
	let err = dx + dy
	const col = color === "transparent" ? null : color
	while (true) {
		renderPixel(x0, y0, color)
		if (x0 === x1 && y0 === y1) break
		const e2 = 2 * err
		if (e2 >= dy) {err += dy; x0 += sx}
		if (e2 <= dx) {err += dx; y0 += sy}
	}
}

// --- Canvas sizing & rendering ---
function resizeCanvases() {
	const cssW = width * pixelSize,
		cssH = height * pixelSize
	displayCanvas.width = cssW
	displayCanvas.height = cssH
	displayCanvas.style.width = cssW + "px"
	displayCanvas.style.height = cssH + "px"
	overlayCanvas.width = cssW
	overlayCanvas.height = cssH
	overlayCanvas.style.width = cssW + "px"
	overlayCanvas.style.height = cssH + "px"
	preview.width = width
	preview.height = height
	// preview.style.width = width <= 32 ? width * 4 + "px" : width + "px"
	// preview.style.height = height <= 32 ? height * 4 + "px" : height + "px"
	preview.style.width = width + "px"
	preview.style.height = height + "px"
	canvasStage.style.width = cssW + "px"
	canvasStage.style.height = cssH + "px"
	drawOverlayGrid()
	renderLayerThumbnails()
	addImageColorsToCustomPalette()
}

function drawOverlayGrid() {
	const ctx = overlayCanvas.getContext("2d")
	ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height)
	if (pixelSize >= 8) {
		ctx.strokeStyle = "rgba(0,0,0,0.06)"
		ctx.lineWidth = 1
		for (let x = 0; x <= width; x++) {
			const px = x * pixelSize + 0.5
			ctx.beginPath()
			ctx.moveTo(px, 0)
			ctx.lineTo(px, overlayCanvas.height)
			ctx.stroke()
		}
		for (let y = 0; y <= height; y++) {
			const py = y * pixelSize + 0.5
			ctx.beginPath()
			ctx.moveTo(0, py)
			ctx.lineTo(overlayCanvas.width, py)
			ctx.stroke()
		}
	}
}

function compositePixelAt(idx) {
	// returns top-most visible pixel color or null
	for (let i = layers.length - 1; i >= 0; i--) {
		if (!layers[i].visible) continue
		const v = layers[i].pixels[idx]
		if (v !== null) return v
	}
	return null
}

function renderDisplay() {
	const ctx = displayCanvas.getContext("2d")
	ctx.clearRect(0, 0, displayCanvas.width, displayCanvas.height) // checkerboard background left to CSS
	for (let y = 0; y < height; y++) {
		for (let x = 0; x < width; x++) {
			const idx = y * width + x
			const color = compositePixelAt(idx)
			if (!color) continue
			ctx.fillStyle = color
			ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize)
		}
	}
}

function renderPreview() {
	const ctx = preview.getContext("2d")
	ctx.clearRect(0, 0, preview.width, preview.height)
	const imgData = ctx.createImageData(width, height)
	const d = imgData.data
	for (let i = 0; i < width * height; i++) {
		const v = compositePixelAt(i)
		const o = i * 4
		updatePixelData(d, o, v)
	}
	ctx.putImageData(imgData, 0, 0)
}

function renderAll() {
	renderDisplay()
	renderPreview()
	updateDataUrl()
	drawOverlay()
}

// --- Pixel helpers per layer ---
function setPixelOnLayer(layerIdx, idx, color) {
	layers[layerIdx].pixels[idx] = color === "transparent" ? null : color
}
function getPixelOnLayer(layerIdx, idx) {
	return layers[layerIdx].pixels[idx]
}

// flood fill on active layer
function floodFillLayer(startIdx, color) {
	const target = getPixelOnLayer(activeLayer, startIdx)
	const replacement = color === "transparent" ? null : color
	if (target === replacement) return
	const stack = [startIdx]
	const visited = new Uint8Array(width * height)
	while (stack.length) {
		const idx = stack.pop()
		if (visited[idx]) continue
		visited[idx] = 1
		if (getPixelOnLayer(activeLayer, idx) !== target) continue
		setPixelOnLayer(activeLayer, idx, replacement)
		const x = idx % width,
			y = Math.floor(idx / width)
		if (x > 0) stack.push(idx - 1)
		if (x < width - 1) stack.push(idx + 1)
		if (y > 0) stack.push(idx - width)
		if (y < height - 1) stack.push(idx + width)
	}
	renderAll()
}

// --- Selection, shapes helpers ---
function clearFloatingSelection() {
	pasteSelBtn.disabled = true
	copySelBtn.disabled = true
	selection = null
	drawOverlay()
}
function copySelectionToClipboard() {
	if (!selection) return
	clipboard = {
		w: selection.w,
		h: selection.h,
		pixels: selection.pixels.slice(),
	}
	pasteSelBtn.disabled = false
	copySelBtn.disabled = true
}
function pasteClipboardAt(x, y) {
	if (!clipboard) return // create floating selection
	selection = {
		x,
		y,
		w: clipboard.w,
		h: clipboard.h,
		pixels: clipboard.pixels.slice(),
		floating: true,
		offsetX: 0,
		offsetY: 0,
	}
	pasteSelBtn.disabled = false
	copySelBtn.disabled = true
	drawOverlay()
}

function commitSelectionToLayer() {
	if (!selection) return // write selection pixels to active layer at selection.x/y
	const sel = selection
	for (let sy = 0; sy < sel.h; sy++) {
		for (let sx = 0; sx < sel.w; sx++) {
			const px = sel.pixels[sy * sel.w + sx]
			if (px !== null) {
				const tx = sel.x + sx
				const ty = sel.y + sy
				if (tx >= 0 && tx < width && ty >= 0 && ty < height) {
					setPixelOnLayer(activeLayer, ty * width + tx, px)
				}
			}
		}
	}
	selection = null
	pasteSelBtn.disabled = false
	copySelBtn.disabled = true
	renderAll()
}

function deleteSelection() {
	if (!selection) return
	selection = null
	pasteSelBtn.disabled = false
	copySelBtn.disabled = true
	drawOverlay()
}

// shapes: create floating shape (rect/ellipse) with editable bounds until confirmed
function commitShape() {
	if (!floatingShape) return
	const renderPixel = (x, y, color) => {
		if (x >= 0 && x < width && y >= 0 && y < height) {
			setPixelOnLayer(activeLayer, y * width + x, color)
		}
	}
	const {type} = floatingShape

	if (type === "line") {
		drawLine(floatingShape, renderPixel)
	}
	if (type === "rect") {
		drawRect(floatingShape, renderPixel)
	}
	if (type === "ellipse") {
		drawEllipse(floatingShape, renderPixel)
	}
	floatingShape = null
	confirmBtn.disabled = true
	cancelBtn.disabled = true
	renderAll()
}

function cancelShape() {
	floatingShape = null
	confirmBtn.disabled = true
	cancelBtn.disabled = true
	drawOverlay()
}

// --- Pointer interaction mapping ---
let isPointerDown = false
let pointerStart = null // {x,y,idx}
let lastIdx = null

function getPointerMap(e) {
	const rect = displayCanvas.getBoundingClientRect()
	const clientX =
    e.clientX === undefined
    	? e.touches && e.touches[0] && e.touches[0].clientX
    	: e.clientX
	const clientY =
    e.clientY === undefined
    	? e.touches && e.touches[0] && e.touches[0].clientY
    	: e.clientY
	const x = Math.floor((clientX - rect.left) / pixelSize)
	const y = Math.floor((clientY - rect.top) / pixelSize)
	if (x < 0 || x >= width || y < 0 || y >= height) return null
	return { x, y, idx: y * width + x }
}

function drawOverlay() {
	const ctx = overlayCanvas.getContext("2d")
	ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height)
	drawOverlayGrid() // draw selection / floating shape / shape preview
	// draw selection box
	if (selection) {
		ctx.save()
		ctx.strokeStyle = "rgba(0,0,0,0.9)"
		ctx.lineWidth = 3
		ctx.setLineDash([4, 2])
		ctx.strokeRect(
			selection.x * pixelSize,
			selection.y * pixelSize,
			selection.w * pixelSize,
			selection.h * pixelSize,
		)
		// draw floating pixels
		if (selection.floating) {
			ctx.globalAlpha = 0.9
			for (let sy = 0; sy < selection.h; sy++) {
				for (let sx = 0; sx < selection.w; sx++) {
					const c = selection.pixels[sy * selection.w + sx]
					if (!c) continue
					ctx.fillStyle = c
					ctx.fillRect(
						(selection.x + sx) * pixelSize,
						(selection.y + sy) * pixelSize,
						pixelSize,
						pixelSize,
					)
				}
			}
			ctx.globalAlpha = 1
		}
		ctx.restore()
	}

	const renderPixel = (x, y, color) => {
		if (x >= 0 && x < width && y >= 0 && y < height) {
			ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize)
		}
	}
	// draw floatingShape preview
	if (floatingShape) {
		ctx.save()
		ctx.globalAlpha = 0.85
		ctx.fillStyle = floatingShape.color
		if (floatingShape.type === "rect") {
			drawRect(floatingShape, renderPixel)
		}
		if (floatingShape.type === "ellipse") {
			drawEllipse(floatingShape, renderPixel)
		}
		if (floatingShape.type === "line") {
			drawLine(floatingShape, renderPixel)
		}
		ctx.restore()
	}
}

// --- Events ---
function attachEvents() {
	displayCanvas.addEventListener("contextmenu", (e) => {
		e.preventDefault()
	})

	displayCanvas.addEventListener("pointerdown", (e) => {
		if (currentTool === 'picker') {
			setPrimary(pickerPreview.style.backgroundColor)
			currentTool = toolBeforePicker
			pickerPreview.style.display = 'none'
			updateToolUI()
			return
		}

		displayCanvas.setPointerCapture(e.pointerId)
		isPointerDown = true
		const pm = getPointerMap(e)
		if (!pm) return
		pointerStart = pm
		lastIdx = pm.idx
		// push undo snapshot (layers deep copy)
		undoStack.push(JSON.stringify(layers))
		const fillShape = document.getElementById('fillShapes').checked

		// right-click sets secondary color
		if (e.button === 2) {
			// right button
			setSecondary(secondaryColor) // no-op, but keep
			// if user right-clicked (we prevented menu) use secondary for immediate pencil
		}

		if (currentTool === "pencil") {
			const col = e.button === 2 ? secondaryColor : primaryColor
			setPixelOnLayer(activeLayer, pm.idx, col === "transparent" ? null : col)
			renderAll()
		} else if (currentTool === "fill") {
			const col = e.button === 2 ? secondaryColor : primaryColor
			floodFillLayer(pm.idx, col)
		} else if (currentTool === "line") {
			confirmBtn.disabled = false
			cancelBtn.disabled = false
			// start preview
			floatingShape = {
				type: "line",
				x: pm.x, y: pm.y,
				x2: pm.x, y2: pm.y,
				color: e.button === 2 ? secondaryColor : primaryColor,
				fillShape,
			}
			drawOverlay()
		} else if (currentTool === "rect" || currentTool === "ellipse") {
			confirmBtn.disabled = false
			cancelBtn.disabled = false
			floatingShape = {
				type: currentTool,
				x: pm.x, y: pm.y,
				w: 1, h: 1,
				color: e.button === 2 ? secondaryColor : primaryColor,
				fillShape,
			}
			drawOverlay()
		} else if (currentTool === "select") {
			confirmBtn.disabled = false
			cancelBtn.disabled = false
			// start selection box
			selection = { x: pm.x, y: pm.y, w: 1, h: 1, pixels: [], floating: false }
			drawOverlay()
		}
		updateUIState()
	})

	displayCanvas.addEventListener('mouseenter', (e) => {
		if (currentTool === 'picker') {
			pickerPreview.style.display = 'block'
		}
	})

	displayCanvas.addEventListener('mouseleave', (e) => {
		if (currentTool === 'picker') {
			pickerPreview.style.display = 'none'
		}
	})

	displayCanvas.addEventListener("mousemove", (e) => {
		const rect = displayCanvas.getBoundingClientRect()
		if (currentTool === 'picker') {
			pickerPreview.style.left = (e.x - 45) + 'px'
			pickerPreview.style.top = (e.y - 45) + 'px'
		}

		const clientX = e.clientX
		const clientY = e.clientY
		const x = Math.floor((clientX - rect.left) / pixelSize)
		const y = Math.floor((clientY - rect.top) / pixelSize)
		if (x < 0 || x >= width || y < 0 || y >= height) return
		setCurrentCursorInfo(x, y)
	})

	displayCanvas.addEventListener("pointermove", (e) => {
		if (!isPointerDown) return
		if (currentTool === 'picker') {
			pickerPreview.style.left = (e.x - 45) + 'px'
			pickerPreview.style.top = (e.y - 45) + 'px'
		}
		const pm = getPointerMap(e)
		if (!pm) return
		setCurrentCursorInfo(pm.x, pm.y)

		if (currentTool === "pencil") {
			const col = e.buttons & 2 ? secondaryColor : primaryColor // right button bit
			// draw line between lastIdx and pm.idx for continuous stroke
			drawLineBetweenOnLayer(lastIdx, pm.idx, col)
			lastIdx = pm.idx
			renderAll()
		} else if (currentTool === "line") {
			if (floatingShape) {
				floatingShape.x2 = pm.x
				floatingShape.y2 = pm.y // create preview pixels as Bresenham between points into floatingShape? we'll draw as preview line
				drawOverlay()
			}
		} else if (currentTool === "rect" || currentTool === "ellipse") {
			if (floatingShape) {
				floatingShape.w = Math.abs(pm.x - floatingShape.x) + 1
				floatingShape.h = Math.abs(pm.y - floatingShape.y) + 1
				floatingShape.x = Math.min(pm.x, floatingShape.x)
				floatingShape.y = Math.min(pm.y, floatingShape.y)
				drawOverlay()
			}
		} else if (currentTool === "select") {
			if (selection) {
				selection.w = Math.abs(pm.x - selection.x) + 1
				selection.h = Math.abs(pm.y - selection.y) + 1
				selection.x = Math.min(pm.x, selection.x)
				selection.y = Math.min(pm.y, selection.y) // copy pixel contents under selection
				const pix = new Array(selection.w * selection.h).fill(null)
				for (let yy = 0; yy < selection.h; yy++) {
					for (let xx = 0; xx < selection.w; xx++) {
						const tx = selection.x + xx,
							ty = selection.y + yy
						if (tx >= 0 && tx < width && ty >= 0 && ty < height)
							pix[yy * selection.w + xx] = getPixelFromComposite(tx, ty)
						else pix[yy * selection.w + xx] = null
					}
				}
				selection.pixels = pix
				drawOverlay()
			}
		}
	})

	window.addEventListener("pointerup", (e) => {
		if (!isPointerDown) return
		isPointerDown = false
		const pm = getPointerMap(e)
		if (currentTool === "line") {
			if (floatingShape) {
				// convert to drawable shape: we'll draw line onto layer when confirmed
				// store as floatingShape of type line that will be committed by Confirm
				// convert endpoints stored
				if (pm) {
					floatingShape.x2 = pm.x
					floatingShape.y2 = pm.y
				}
				drawOverlay()
			}
		} else if (currentTool === "rect" || currentTool === "ellipse") {
			// keep floating until confirmed
		} else if (currentTool === "select") {
			// finalize selection pixels and leave selection active but not floating
			if (selection) {
				selection.floating = false
				drawOverlay()
			}
		}
		updateUIState()
		renderLayerThumbnails()
	})

	// UI controls
	document.getElementById("applySize").addEventListener("click", () => {
		const newW = parseInt(document.getElementById("width").value, 10)
		const newH = parseInt(document.getElementById("height").value, 10)
		const newPixels = new Array(newW * newH).fill(null)
		// copy per layer
		for (let li = 0; li < layers.length; li++) {
			const old = layers[li].pixels
			const dest = new Array(newW * newH).fill(null)
			for (let y = 0; y < Math.min(newH, height); y++) {
				for (let x = 0; x < Math.min(newW, width); x++) {
					dest[y * newW + x] = old[y * width + x]
				}
			}
			layers[li].pixels = dest
		}
		width = newW
		height = newH
		resizeCanvases()
		renderAll()
	})

	document.getElementById("zoomIn").addEventListener("click", () => {
		pixelSize = Math.min(64, pixelSize + 4)
		document.getElementById("zoomVal").textContent = pixelSize
		resizeCanvases()
		renderAll()
		saveToLocalStorage()
	})
	document.getElementById("zoomOut").addEventListener("click", () => {
		pixelSize = Math.max(4, pixelSize - 4)
		document.getElementById("zoomVal").textContent = pixelSize
		resizeCanvases()
		renderAll()
		saveToLocalStorage()
	})

	document
		.getElementById("colorPicker")
		.addEventListener("input", (e) => setPrimary(e.target.value))
	document
		.getElementById("colorPicker2")
		.addEventListener("input", (e) => setSecondary(e.target.value))

	document.getElementById("clearBtn").addEventListener("click", () => {
		layers.forEach((l) => l.pixels.fill(null))
		renderAll()
	})

	document.getElementById("copyUrlBtn").addEventListener("click", async () => {
		try {
			await navigator.clipboard.writeText(
				document.getElementById("dataUrlInput").value,
			)
			showNotification("Copied!")
		} catch (e) {
			showNotification("Copy failed.")
		}
	})
	document.getElementById("downloadBtn").addEventListener("click", () => {
		const a = document.createElement("a")
		a.href = document.getElementById("dataUrlInput").value
		a.download = "pixelart.png"

		a.style.display = 'none'
		document.body.appendChild(a)

		a.click()

		document.body.removeChild(a)
	})
	document.getElementById("downloadLayersBtn").addEventListener("click", () => {
		const data = {
			width,
			height,
			pixelSize,
			activeLayer,
			primaryColor,
			secondaryColor,
			currentTool,
			layers,
		}
		const text = JSON.stringify(data, null, '\t')
		const a = document.createElement('a')
		a.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text))
		a.setAttribute('download', "pixelart.json")

		a.style.display = 'none'
		document.body.appendChild(a)

		a.click()

		document.body.removeChild(a)
	})
	document.getElementById("undoBtn").addEventListener("click", () => {
		const s = undoStack.pop()
		if (!s) return
		layers = JSON.parse(s)
		activeLayer = Math.max(0, Math.min(activeLayer, layers.length - 1))
		renderLayersUI()
		renderAll()
	})

	document.getElementById("pasteBase64Btn").addEventListener("click", () => {
		const base64 = document.getElementById("dataUrlInput").value.trim()
		if (base64.startsWith("data:image")) loadBase64(base64)
		else showNotification("Invalid base64 PNG data URL.")
	})
	document.getElementById("fileInput").addEventListener("change", () => {
		const file = document.getElementById("fileInput").files[0]
		if (!file) return
		const reader = new FileReader()
		reader.onload = (e) => loadBase64(e.target.result)
		reader.readAsDataURL(file)
	})
	document.getElementById("layersFileInput").addEventListener("change", () => {
		const file = document.getElementById("layersFileInput").files[0]
		if (!file) return
		const reader = new FileReader()
		reader.onload = (e) => {
			try {
				const data = JSON.parse(e.target.result)
				const loadedLayers = data.layers

				if (!data.width || !data.height || !data.pixelSize || !Array.isArray(loadedLayers)) {
					throw new Error("Invalid image file.")
				}

				width = data.width
				height = data.height
				pixelSize = data.pixelSize
				activeLayer = data.activeLayer || 0
				primaryColor = data.primaryColor
				secondaryColor = data.secondaryColor
				currentTool = data.currentTool || "pencil"

				document.getElementById("width").value = width
				document.getElementById("height").value = height
				document.getElementById("zoomVal").textContent = pixelSize

				layers = loadedLayers

				resizeCanvases()
				renderLayersUI()
				renderAll()
			} catch (err) {
				showNotification.error("Error loading layers file.")
			}
		}
		reader.readAsText(file)
	})

	document.getElementById("toolPencil").addEventListener("click", () => {
		currentTool = "pencil"
		updateToolUI()
	})
	document.getElementById("toolPicker").addEventListener("click", () => {
		toolBeforePicker = currentTool || "pencil"
		currentTool = "picker"
		updateToolUI()
	})
	document.getElementById("toolFill").addEventListener("click", () => {
		currentTool = "fill"
		updateToolUI()
	})
	document.getElementById("toolLine").addEventListener("click", () => {
		currentTool = "line"
		updateToolUI()
	})
	document.getElementById("toolRect").addEventListener("click", () => {
		currentTool = "rect"
		updateToolUI()
	})
	document.getElementById("toolEllipse").addEventListener("click", () => {
		currentTool = "ellipse"
		updateToolUI()
	})
	document.getElementById("toolSelect").addEventListener("click", () => {
		currentTool = "select"
		updateToolUI()
	})
	document.getElementById("colorSwitch").addEventListener("click", () => {
		const c = primaryColor
		primaryColor = secondaryColor
		secondaryColor = c
		setPrimary(primaryColor)
		setSecondary(secondaryColor)
		updateToolUI()
	})

	document.getElementById("confirmBtn").addEventListener("click", () => {
		// confirm both floating shape and selection
		if (floatingShape) {
			commitShape()
			renderLayerThumbnails()
			return
		}
		if (selection) {
			// commit selection to active layer (paste) if floating or just finalize
			commitSelectionToLayer()
			renderLayerThumbnails()
			return
		}
	})
	document.getElementById("cancelBtn").addEventListener("click", () => {
		floatingShape = null
		selection = null
		confirmBtn.disabled = true
		cancelBtn.disabled = true
		drawOverlay()
	})
	document.getElementById("copySelBtn").addEventListener("click", () => {
		copySelectionToClipboard()
		showNotification("Selection copied to clipboard (internal)")
	})
	document.getElementById("pasteSelBtn").addEventListener("click", () => {
		// paste at 0,0 by default
		if (!clipboard) {
			showNotification("Clipboard empty")
			return
		}
		confirmBtn.disabled = false
		cancelBtn.disabled = false
		pasteClipboardAt(0, 0)
	})
	document.getElementById('showHideControls').addEventListener('click', () => {
		const panel = document.getElementById('sidePanel-controls')
		const button = document.getElementById('showHideControls')
		if (panel.style.display === 'none') {
			panel.style.display = 'block'
			button.textContent = '‚óÄÔ∏è'
			button.style.left = 'calc(var(--controls-width) - 40px)'
		} else {
			panel.style.display = 'none'
			button.textContent = '‚ñ∂Ô∏è'
			button.style.left = '10px'
		}
	})

	document.getElementById('showHideLayers').addEventListener('click', () => {
		const panel = document.getElementById('sidePanel-layers')
		const button = document.getElementById('showHideLayers')
		if (panel.style.display === 'none') {
			panel.style.display = 'block'
			button.textContent = '‚óÄÔ∏è'
		} else {
			panel.style.display = 'none'
			button.textContent = '‚ñ∂Ô∏è'
		}
	})

	// layers controls
	document.getElementById("addLayer").addEventListener("click", () => {
		addLayer()
		renderAll()
	})
	document.getElementById("deleteLayer").addEventListener("click", () => {
		deleteLayer(activeLayer)
	})
	document.getElementById("moveUp").addEventListener("click", () => {
		moveLayerUp(activeLayer)
	})
	document.getElementById("moveDown").addEventListener("click", () => {
		moveLayerDown(activeLayer)
	})
	document.getElementById("mergeDown").addEventListener("click", () => {
		mergeDown(activeLayer)
	})

	window.addEventListener("keydown", (e) => {
		console.log(e)
		if (e.code === "Enter") {
			document.getElementById("confirmBtn").click()
		}
		if (e.code === "Escape") {
			document.getElementById("cancelBtn").click()
		}
		// arrow keys move selection by 1px if selection exists
		if (selection) {
			let moved = false
			if (e.code === "ArrowLeft") { selection.x = selection.x - 1; moved = true }
			if (e.code === "ArrowRight") { selection.x = selection.x + 1; moved = true }
			if (e.code === "ArrowUp") { selection.y = selection.y - 1; moved = true }
			if (e.code === "ArrowDown") { selection.y = selection.y + 1; moved = true }
			if (moved) { drawOverlay(); e.preventDefault(); return }
		}
		// CMD+A (macOS) or CTRL+A - select all
		if ((e.metaKey || e.ctrlKey) && e.code === "KeyA") {
			e.preventDefault()
			selection = {
				x: 0,
				y: 0,
				w: width,
				h: height,
				pixels: [],
				floating: false,
			}
			// Copy all pixels from active layer to selection
			for (let i = 0; i < width * height; i++) {
				selection.pixels[i] = getPixelOnLayer(activeLayer, i)
			}
			drawOverlay()
			copySelBtn.disabled = false
			pasteSelBtn.disabled = true
			return
		}
		if (e.code === "KeyP") {
			currentTool = "pencil"
			updateToolUI()
		}
		if (e.code === "KeyI") {
			currentTool = "picker"
			updateToolUI()
		}
		if (e.code === "KeyB") {
			currentTool = "fill"
			updateToolUI()
		}
		if (e.code === "KeyL") {
			currentTool = "line"
			updateToolUI()
		}
		if (e.code === "KeyR") {
			currentTool = "rect"
			updateToolUI()
		}
		if (e.code === "KeyE") {
			currentTool = "ellipse"
			updateToolUI()
		}
		if (e.code === "KeyA") {
			currentTool = "select"
			updateToolUI()
		}
		if (e.code === "KeyO") {
			document.getElementById("colorSwitch").click()
			updateToolUI()
		}
	})

	document.getElementById("isoShowHide").addEventListener("click", () => {
		showIsometricGrid = !showIsometricGrid
		document.getElementById("isoShowHide").textContent = showIsometricGrid
			? "Hide Isometric Grid"
			: "Show Isometric Grid"
		drawOverlayGrid()
	})
}

function updateToolUI() {
	document
		.getElementById("toolPencil")
		.classList.toggle("active", currentTool === "pencil")
	document
		.getElementById("toolPicker")
		.classList.toggle("active", currentTool === "picker")
	document
		.getElementById("toolFill")
		.classList.toggle("active", currentTool === "fill")
	document
		.getElementById("toolLine")
		.classList.toggle("active", currentTool === "line")
	document
		.getElementById("toolRect")
		.classList.toggle("active", currentTool === "rect")
	document
		.getElementById("toolEllipse")
		.classList.toggle("active", currentTool === "ellipse")
	document
		.getElementById("toolSelect")
		.classList.toggle("active", currentTool === "select")
	document.getElementById("toolLabel").textContent =
    currentTool.charAt(0).toUpperCase() + currentTool.slice(1)
}

function drawLineBetweenOnLayer(aIdx, bIdx, color) {
	if (aIdx === null || bIdx === null) return
	let x0 = aIdx % width,
		y0 = Math.floor(aIdx / width)
	const x1 = bIdx % width,
		y1 = Math.floor(bIdx / width)
	let dx = Math.abs(x1 - x0),
		sx = x0 < x1 ? 1 : -1
	let dy = -Math.abs(y1 - y0),
		sy = y0 < y1 ? 1 : -1
	let err = dx + dy
	const col = color === "transparent" ? null : color
	while (true) {
		setPixelOnLayer(activeLayer, y0 * width + x0, col)
		if (x0 === x1 && y0 === y1) break
		const e2 = 2 * err
		if (e2 >= dy) {
			err += dy
			x0 += sx
		}
		if (e2 <= dx) {
			err += dx
			y0 += sy
		}
	}
}

function getPixelFromComposite(x, y) {
	const idx = y * width + x
	return compositePixelAt(idx)
}

// --- Export / Import ---
function updatePixelData(data, index, pixelValue) {
	if (!pixelValue) {
		data[index] = 0
		data[index + 1] = 0
		data[index + 2] = 0
		data[index + 3] = 0
	} else if (pixelValue[0] === "#") {
		data[index] = parseInt(pixelValue.substring(1, 3), 16)
		data[index + 1] = parseInt(pixelValue.substring(3, 5), 16)
		data[index + 2] = parseInt(pixelValue.substring(5, 7), 16)
		data[index + 3] = 255
	} else if (pixelValue.startsWith("rgba")) {
		const nums = pixelValue.match(/rgba\((\d+),(\d+),(\d+),(\d*\.?\d+)\)/)
		if (nums) {
			data[index] = parseInt(nums[1], 10)
			data[index + 1] = parseInt(nums[2], 10)
			data[index + 2] = parseInt(nums[3], 10)
			data[index + 3] = Math.round(parseFloat(nums[4]) * 255)
		}
	}
}

function updateDataUrl() {
	const c = document.createElement("canvas")
	c.width = width
	c.height = height
	const ctx = c.getContext("2d")
	const imgData = ctx.createImageData(width, height)

	for (let i = 0; i < width * height; i++) {
		const v = compositePixelAt(i)
		updatePixelData(imgData.data, i * 4, v)
	}
	ctx.putImageData(imgData, 0, 0)
	const url = c.toDataURL("image/png")
	document.getElementById("dataUrlInput").value = url
	saveToLocalStorage()
}

function loadBase64(base64) {
	const img = new Image()
	img.onload = () => {
		width = img.width
		height = img.height
		document.getElementById("width").value = width
		document.getElementById("height").value = height // single-layer import into layer0
		for (let li = 0; li < layers.length; li++) {
			layers[li].pixels = new Array(width * height).fill(null)
		}
		const temp = document.createElement("canvas")
		temp.width = width
		temp.height = height
		const ctx = temp.getContext("2d")
		ctx.drawImage(img, 0, 0)
		const data = ctx.getImageData(0, 0, width, height).data
		for (let i = 0; i < width * height; i++) {
			const r = data[i * 4],
				g = data[i * 4 + 1],
				b = data[i * 4 + 2],
				a = data[i * 4 + 3]
			layers[0].pixels[i] = a === 0 ? null : `rgba(${r},${g},${b},${(a / 255).toFixed(3)})`
		}
		resizeCanvases()
		renderAll()
		addImageColorsToCustomPalette()
		renderLayerThumbnails()
	}
	img.src = base64
}

function removeLayer(i) {
	if (layers.length <= 1) return
	layers.splice(i, 1)
	activeLayer = Math.max(0, Math.min(activeLayer, layers.length - 1))
	renderLayersUI()
	renderAll()
}
function moveLayer(i, dir) {
	const to = i + dir
	if (to < 0 || to >= layers.length) return
	const a = layers.splice(i, 1)[0]
	layers.splice(to, 0, a)
	activeLayer = to
	renderLayersUI()
	renderAll()
}
function mergeDown(i) {
	if (i <= 0) return
	const top = layers[i],
		bot = layers[i - 1]
	for (let p = 0; p < width * height; p++) {
		if (top.pixels[p] != null) bot.pixels[p] = top.pixels[p]
	}
	layers.splice(i, 1)
	activeLayer = i - 1
	renderLayersUI()
	renderAll()
}

function renderLayersUI() {
	const list = document.getElementById("layersList")
	list.innerHTML = ""
	for (let i = layers.length - 1; i >= 0; i--) {
		const li = layers[i]
		const idx = i
		const el = document.createElement("div")
		el.className = "layer-item" + (i === activeLayer ? " active" : "")
		el.draggable = true
		el.dataset.index = i
		const thumb = document.createElement("canvas")
		thumb.className = "layer-thumb"
		thumb.width = width
		thumb.height = height
		thumb.style.width = "56px"
		thumb.style.height = "56px"
		const tctx = thumb.getContext("2d")
		const img = tctx.createImageData(width, height)
		for (let p = 0; p < width * height; p++) {
			const v = layers[i].pixels[p]
			updatePixelData(img.data, p * 4, v)
		}
		tctx.putImageData(img, 0, 0)
		const meta = document.createElement("div")
		meta.style.display = "flex"
		meta.style.flexDirection = "column"
		meta.style.marginLeft = "8px"
		const name = document.createElement("div")
		name.textContent = li.name
		const vis = document.createElement("input")
		vis.type = "checkbox"
		vis.checked = li.visible
		vis.addEventListener("change", () => {
			li.visible = vis.checked
			renderAll()
		})
		meta.appendChild(name)
		meta.appendChild(vis)
		const ctr = document.createElement("div")
		ctr.className = "layer-controls"
		const sel = document.createElement("button")
		sel.textContent = "Select"
		sel.addEventListener("click", () => {
			activeLayer = idx
			renderLayersUI()
		})

		const del = document.createElement("button")
		del.textContent = "üóëÔ∏è"
		del.title = "Delete Layer"
		del.addEventListener("click", () => {
			removeLayer(idx)
		})
		ctr.appendChild(sel)
		ctr.appendChild(del)
		el.appendChild(thumb)
		el.appendChild(meta)
		el.appendChild(ctr)
		list.appendChild(el)
	}
	renderLayerThumbnails()
	updateUIState()
}


const layersList = document.getElementById("layersList")
layersList.addEventListener("dragstart", (e) => {
	const item = e.target.closest(".layer-item")
	if (!item) return
	e.dataTransfer.setData("text/layer", item.dataset.index)
	item.classList.add("dragging")
})
layersList.addEventListener("dragend", (e) => {
	const item = e.target.closest(".layer-item")
	if (item) item.classList.remove("dragging")
})
layersList.addEventListener("dragover", (e) => {
	e.preventDefault()
})
layersList.addEventListener("drop", (e) => {
	e.preventDefault()
	const from = +e.dataTransfer.getData("text/layer")
	const toEl = e.target.closest(".layer-item")
	if (!toEl) return
	const to = +toEl.dataset.index
	const item = layers.splice(from, 1)[0]
	layers.splice(to, 0, item)
	renderLayersUI()
	renderAll()
})

function renderLayerThumbnails() {
	// small update for any thumb canvases
	const thumbs = document.querySelectorAll(".layer-thumb")
	thumbs.forEach((thumb, i) => {
		thumb.width = Math.max(width, height)
		thumb.height = Math.max(width, height)

		const index = layers.length - 1 - i
		const tctx = thumb.getContext("2d")
		tctx.clearRect(0, 0, thumb.width, thumb.height)
		const imgd = tctx.createImageData(width, height)
		for (let p = 0; p < width * height; p++) {
			updatePixelData(imgd.data, p * 4, layers[index].pixels[p])
		}
		tctx.putImageData(imgd, 0, 0)
	})
}

// init
init()
</script>
</body>

</html>

<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Standalone Pixel Art Editor ‚Äî Tools: Pencil / Fill / Line</title>
	<style>
		:root {
			--cell-border: 1px solid #222;
			--bg: #f3f3f3;
			--panel-bg: #fff;
			--accent: #0b84ff;
		}

		body {
			font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial;
			background: var(--bg);
			margin: 16px;
			color: #111
		}

		.app {
			display: flex;
			gap: 16px;
			align-items: flex-start
		}

		.panel {
			background: var(--panel-bg);
			padding: 12px;
			border-radius: 8px;
			box-shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
		}

		.controls {
			width: 360px
		}

		.row {
			display: flex;
			gap: 8px;
			align-items: center;
			margin-bottom: 8px
		}

		label {
			font-size: 13px;
			min-width: 72px
		}

		input[type=number] {
			width: 40px;
			padding: 6px;
			border-radius: 6px;
			border: 1px solid #ccc
		}

		input[type=text] {
			width: 100%;
			padding: 6px;
			border-radius: 6px;
			border: 1px solid #ccc
		}

		button {
			padding: 6px 10px;
			border-radius: 6px;
			border: 1px solid #bbb;
			background: white;
			cursor: pointer;
			display: inline-flex;
			align-items: center;
			gap: 6px;
		}

		.palette {
			display: flex;
			gap: 6px;
			flex-wrap: wrap
		}

		.palette button {
			width: 36px;
			height: 28px;
			padding: 0;
			border: 2px solid #ddd
		}

		.grid-wrap {
			background: linear-gradient(#fff, #eee);
			padding: 12px;
			border-radius: 8px
		}

		.grid {
			display: grid;
			background: transparent;
			touch-action: none;
			user-select: none;
		}

		.cell {
			box-sizing: border-box;
			border: var(--cell-border);
			cursor: pointer;
		}

		.preview {
			margin-top: 12px;
			border: 1px solid #ccc;
			display: inline-block
		}

		.small {
			font-size: 12px;
			color: #555
		}

		.controls .foot {
			margin-top: 12px;
			font-size: 12px;
			color: #666
		}

		/* toolbar */
		.toolbar {
			display: flex;
			gap: 8px;
			margin-top: 8px;
			margin-bottom: 8px;
			align-items: center;
		}

		.tool-btn {
			border: 1px solid #ccc;
			padding: 6px 10px;
			border-radius: 6px;
			background: white;
			display: inline-flex;
			align-items: center;
			gap: 8px;
			cursor: pointer;
		}

		.tool-btn.active {
			border-color: var(--accent);
			box-shadow: 0 4px 12px rgba(11,132,255,0.12);
			background: linear-gradient(#fff, #f0fbff);
		}

		.tool-icon {
			font-size: 16px;
			line-height: 1;
		}

		/* small label next to preview */
		.preview-wrap { display:flex; gap:12px; align-items:center; margin-top:12px; }
	</style>
</head>

<body>
	<h1>Pixel Art Editor ‚Äî Pencil / Fill / Line</h1>
	<div class="app">
		<div class="panel controls">
			<h2>Image & Controls</h2>

			<div class="row">
				<label for="width">Width</label>
				<input id="width" type="number" min="1" max="256" value="16">
				<label for="height">Height</label>
				<input id="height" type="number" min="1" max="256" value="16">
				<button id="applySize">Apply size</button>
			</div>

			<div class="row">
				<label>Zoom</label>
				<button id="zoomOut">‚àí</button>
				<span id="zoomVal">16</span> px
				<button id="zoomIn">+</button>
			</div>

			<h2>Color</h2>
			<div class="row">
				<label for="colorPicker">Picker</label>
				<input id="colorPicker" type="color" value="#ff0000">
				<div class="small">Current: <span id="currentColor">#ff0000</span></div>
			</div>
			<div class="row palette" id="palette"></div>

			<div style="margin-top:8px">
				<div class="small">Set RGB:</div>
				<div class="row">
					<input id="r" type="number" min="0" max="255" placeholder="R" style="width:60px">
					<input id="g" type="number" min="0" max="255" placeholder="G" style="width:60px">
					<input id="b" type="number" min="0" max="255" placeholder="B" style="width:60px">
					<button id="setRgb">Set</button>
				</div>
			</div>

			<!-- TOOLBAR -->
			<h3 style="margin-top:12px; margin-bottom:6px">Tool</h3>
			<div class="toolbar" role="toolbar" aria-label="Tools">
				<button id="toolPencil" class="tool-btn" title="Pencil (default)"><span class="tool-icon">üñâ</span><span>Pencil</span></button>
				<button id="toolFill" class="tool-btn" title="Fill"><span class="tool-icon">ü™£</span><span>Fill</span></button>
				<button id="toolLine" class="tool-btn" title="Line"><span class="tool-icon">üìè</span><span>Line</span></button>
			</div>

			<h2>Import / Export</h2>
			<div class="row">
				<input type="file" id="fileInput" accept="image/png" />
			</div>

			<div style="margin-top:12px">
				<div class="small">Image data URL (updates on every change)</div>
				<input id="dataUrlInput" type="text">
				<div class="row" style="margin-top:8px">
					<button id="pasteBase64Btn">Load from base64</button>
				</div>
				<div class="row" style="margin-top:8px">
					<button id="clearBtn">Clear image</button>
				</div>
				<div class="row" style="margin-top:8px">
					<button id="copyBtn">Copy</button>
					<button id="downloadBtn">Download PNG</button>
				</div>
			</div>

			<div class="foot">Tip: click / drag cells to paint with Pencil. Use Fill to flood-fill a contiguous area. Use Line to draw straight lines between pointer-down and pointer-up.</div>
		</div>

		<div class="panel">
			<h2>Editor</h2>
			<div class="grid-wrap">
				<div id="grid" class="grid" style="--cols:16"></div>
			</div>
			<div class="preview-wrap">
				<div>
					<div>Preview (native resolution):</div>
					<canvas id="preview" class="preview"></canvas>
				</div>
				<div class="small" style="opacity:0.8">Tool: <span id="toolLabel">Pencil</span></div>
			</div>
		</div>
	</div>

	<script>
		// state
		let isPainting = false
		let width = 16, height = 16
		let pixelSize = 16
		let currentColor = '#ff0000'
		let pixels = []

		let currentTool = 'pencil' // 'pencil' | 'fill' | 'line'
		let lineStartIdx = null

		const gridEl = document.getElementById('grid')
		const preview = document.getElementById('preview')
		const dataUrlInput = document.getElementById('dataUrlInput')
		const fileInput = document.getElementById('fileInput')

		const toolLabel = document.getElementById('toolLabel')

		const basicColors = ['transparent', '#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#8b4513', '#808080']

		// init
		function init() {
			loadFromLocalStorage()
			if (pixels.length === 0) initPixels()
			buildPalette()
			renderGrid()
			renderPreview()
			updateDataUrl()
			attachEvents()
			updateToolUI()
		}

		function buildPalette() {
			const pal = document.getElementById('palette')
			pal.innerHTML = ''
			basicColors.forEach(c => {
				const b = document.createElement('button')
				if (c === 'transparent') {
					b.style.background = "repeating-conic-gradient(#ccc 0% 25%, #eee 0% 50%) 50% / 6px 6px"
				} else b.style.background = c
				b.addEventListener('click', () => setCurrentColor(c))
				pal.appendChild(b)
			})
		}

		function initPixels() { pixels = new Array(width * height).fill('transparent') }

		function setCurrentColor(hex) {
			currentColor = hex
			document.getElementById('currentColor').textContent = hex
			if (hex === 'transparent') return
			document.getElementById('colorPicker').value = hex
			document.getElementById('r').value = parseInt(hex.substring(1, 3), 16)
			document.getElementById('g').value = parseInt(hex.substring(3, 5), 16)
			document.getElementById('b').value = parseInt(hex.substring(5, 7), 16)
		}

		function renderGrid() {
			gridEl.innerHTML = ''
			gridEl.style.gridTemplateColumns = `repeat(${width}, ${pixelSize}px)`
			gridEl.style.gridTemplateRows = `repeat(${height}, ${pixelSize}px)`

			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const idx = y * width + x
					const cell = document.createElement('div')
					cell.className = 'cell'
					cell.dataset.idx = idx
					cell.style.width = pixelSize + 'px'
					cell.style.height = pixelSize + 'px'
					cell.style.background = pixels[idx] === 'transparent' ? "repeating-conic-gradient(#ccc 0% 25%, #eee 0% 50%) 50% / 6px 6px" : pixels[idx]
					gridEl.appendChild(cell)
				}
			}
		}

		function paintCell(cell, color = currentColor, quiet = false) {
			const idx = parseInt(cell.dataset.idx, 10)
			pixels[idx] = color
			cell.style.background = color === 'transparent' ? "repeating-conic-gradient(#ccc 0% 25%, #eee 0% 50%) 50% / 6px 6px" : color
			if (!quiet) {
				renderPreview()
				updateDataUrl()
			}
		}

		function setPixelIdx(idx, color) {
			pixels[idx] = color
			// update cell DOM if visible
			const cell = gridEl.querySelector(`.cell[data-idx='${idx}']`)
			if (cell) {
				cell.style.background = color === 'transparent' ? "repeating-conic-gradient(#ccc 0% 25%, #eee 0% 50%) 50% / 6px 6px" : color
			}
		}

		function renderPreview() {
			preview.width = width
			preview.height = height
			const ctx = preview.getContext('2d')
			ctx.clearRect(0, 0, width, height)
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const idx = y * width + x
					if (pixels[idx] !== 'transparent') {
						ctx.fillStyle = pixels[idx]
						ctx.fillRect(x, y, 1, 1)
					} else {
						// clear pixel ‚Äî leave transparent
						ctx.clearRect(x, y, 1, 1)
					}
				}
			}
		}

		function updateDataUrl() {
			const c = document.createElement('canvas')
			c.width = width
			c.height = height
			const ctx = c.getContext('2d')
			ctx.clearRect(0, 0, width, height)
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const idx = y * width + x
					if (pixels[idx] !== 'transparent') {
						ctx.fillStyle = pixels[idx]
						ctx.fillRect(x, y, 1, 1)
					}
				}
			}
			const url = c.toDataURL('image/png')
			dataUrlInput.value = url
			saveToLocalStorage()
		}

		function saveToLocalStorage() {
			localStorage.setItem('pixelart_dataurl', dataUrlInput.value)
		}

		function loadFromLocalStorage() {
			const saved = localStorage.getItem('pixelart_dataurl')
			if (!saved) return
			loadBase64(saved)
		}

		function loadBase64(base64) {
			const img = new Image()
			img.onload = () => {
				width = img.width
				height = img.height
				document.getElementById('width').value = width
				document.getElementById('height').value = height
				const temp = document.createElement('canvas')
				temp.width = width
				temp.height = height
				const ctx = temp.getContext('2d')
				ctx.drawImage(img, 0, 0)
				const data = ctx.getImageData(0, 0, width, height).data
				pixels = new Array(width * height)
				for (let i = 0; i < pixels.length; i++) {
					const r = data[i * 4], g = data[i * 4 + 1], b = data[i * 4 + 2], a = data[i * 4 + 3]
					pixels[i] = a === 0 ? 'transparent' : `rgba(${r},${g},${b},${a / 255})`
				}
				renderGrid()
				renderPreview()
				updateDataUrl()
			}
			img.src = base64
		}

		// TOOLING: flood fill and line (Bresenham)
		function floodFill(startIdx) {
			const target = pixels[startIdx]
			const replacement = currentColor
			if (target === replacement) return
			const q = [startIdx]
			const visited = new Uint8Array(width * height) // 0/1 visited
			while (q.length) {
				const idx = q.shift()
				if (visited[idx]) continue
				visited[idx] = 1
				if (pixels[idx] !== target) continue
				setPixelIdx(idx, replacement)
				const x = idx % width
				const y = Math.floor(idx / width)
				if (x > 0) q.push(idx - 1)
				if (x < width - 1) q.push(idx + 1)
				if (y > 0) q.push(idx - width)
				if (y < height - 1) q.push(idx + width)
			}
			// refresh
			renderPreview()
			updateDataUrl()
		}

		// Temporary preview pixels (for line preview)
		let previewPixels = new Set()

		function clearPreview() {
			for (const idx of previewPixels) {
				const cell = gridEl.querySelector(`.cell[data-idx='${idx}']`)
				if (cell) {
					const color = pixels[idx]
					cell.style.background = color === 'transparent'
						? "repeating-conic-gradient(#ccc 0% 25%, #eee 0% 50%) 50% / 6px 6px"
						: color
				}
			}
			previewPixels.clear()
		}

		function drawPreviewLine(startIdx, endIdx) {
			clearPreview()

			let x0 = startIdx % width
			let y0 = Math.floor(startIdx / width)
			const x1 = endIdx % width
			const y1 = Math.floor(endIdx / width)

			let dx = Math.abs(x1 - x0)
			const sx = x0 < x1 ? 1 : -1
			let dy = -Math.abs(y1 - y0)
			const sy = y0 < y1 ? 1 : -1
			let err = dx + dy

			while (true) {
				const idx = y0 * width + x0
				previewPixels.add(idx)

				const cell = gridEl.querySelector(`.cell[data-idx='${idx}']`)
				if (cell) cell.style.background = currentColor

				if (x0 === x1 && y0 === y1) break
				const e2 = 2 * err
				if (e2 >= dy) { err += dy; x0 += sx }
				if (e2 <= dx) { err += dx; y0 += sy }
			}
		}

		function drawLineByIdx(startIdx, endIdx) {
			let x0 = startIdx % width
			let y0 = Math.floor(startIdx / width)
			const x1 = endIdx % width
			const y1 = Math.floor(endIdx / width)

			let dx = Math.abs(x1 - x0)
			const sx = x0 < x1 ? 1 : -1
			let dy = -Math.abs(y1 - y0)
			const sy = y0 < y1 ? 1 : -1
			let err = dx + dy

			while (true) {
				const idx = y0 * width + x0
				setPixelIdx(idx, currentColor)
				if (x0 === x1 && y0 === y1) break
				const e2 = 2 * err
				if (e2 >= dy) { err += dy; x0 += sx }
				if (e2 <= dx) { err += dx; y0 += sy }
			}
			renderPreview();
			updateDataUrl();
		}

		function getCellIdxFromEventTarget(target) {
			const cell = target.closest ? target.closest('.cell') : null
			if (!cell) return null
			return parseInt(cell.dataset.idx, 10)
		}

		// Attach events with tool behavior
		function attachEvents() {
			// pointer interactions on the grid
			gridEl.addEventListener('pointerdown', e => {
				const cell = e.target.closest ? e.target.closest('.cell') : null
				if (!cell) return
				const idx = parseInt(cell.dataset.idx, 10)

				if (currentTool === 'pencil') {
					isPainting = true
					paintCell(cell)
				} else if (currentTool === 'fill') {
					floodFill(idx)
				} else if (currentTool === 'line') {
					lineStartIdx = idx
					clearPreview()
				}
			})

			gridEl.addEventListener('pointermove', e => {
				const cell = e.target.closest ? e.target.closest('.cell') : null
				if (!cell) return

				// Pencil drag
				if (currentTool === 'pencil') {
					if (isPainting) paintCell(cell)
					return
				}

				// Line preview
				if (currentTool === 'line' && lineStartIdx !== null) {
					const idx = parseInt(cell.dataset.idx, 10)
					drawPreviewLine(lineStartIdx, idx)
				}
			})

			window.addEventListener('pointerup', e => {
				if (currentTool === 'pencil') {
					isPainting = false
					return
				}

				if (currentTool === 'line') {
					if (lineStartIdx !== null) {
						const idx = getCellIdxFromEventTarget(e.target)
						clearPreview() // remove ghost pixels

						if (idx !== null) {
							drawLineByIdx(lineStartIdx, idx)
						}

						lineStartIdx = null
					}
				}
			})


			// size / zoom / color events
			document.getElementById('applySize').addEventListener('click', () => {
				const newW = parseInt(document.getElementById('width').value, 10)
				const newH = parseInt(document.getElementById('height').value, 10)
				const newPixels = new Array(newW * newH).fill('transparent')
				for (let y = 0; y < Math.min(newH, height); y++) {
					for (let x = 0; x < Math.min(newW, width); x++) {
						newPixels[y * newW + x] = pixels[y * width + x]
					}
				}
				width = newW
				height = newH
				pixels = newPixels
				renderGrid()
				renderPreview()
				updateDataUrl()
			})

			document.getElementById('zoomIn').addEventListener('click', () => {
				pixelSize = Math.min(64, pixelSize + 4)
				document.getElementById('zoomVal').textContent = pixelSize
				renderGrid()
			})
			document.getElementById('zoomOut').addEventListener('click', () => {
				pixelSize = Math.max(4, pixelSize - 4)
				document.getElementById('zoomVal').textContent = pixelSize
				renderGrid()
			})

			document.getElementById('colorPicker').addEventListener('input', e => setCurrentColor(e.target.value))

			document.getElementById('setRgb').addEventListener('click', () => {
				const r = document.getElementById('r').value | 0
				const g = document.getElementById('g').value | 0
				const b = document.getElementById('b').value | 0
				setCurrentColor(`#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`)
			})

			document.getElementById('clearBtn').addEventListener('click', () => {
				pixels.fill('transparent')
				renderGrid()
				renderPreview()
				updateDataUrl()
			})

			document.getElementById('copyBtn').addEventListener('click', async () => {
				try { await navigator.clipboard.writeText(dataUrlInput.value); alert('Copied!') }
				catch (e) { alert('Copy failed.') }
			})

			document.getElementById('downloadBtn').addEventListener('click', () => {
				const a = document.createElement('a')
				a.href = dataUrlInput.value
				a.download = 'pixelart.png'
				a.click()
			})

			fileInput.addEventListener('change', () => {
				const file = fileInput.files[0]
				if (!file) return
				const reader = new FileReader()
				reader.onload = e => loadBase64(e.target.result)
				reader.readAsDataURL(file)
			})

			document.getElementById('pasteBase64Btn').addEventListener('click', () => {
				const base64 = dataUrlInput.value.trim()
				if (base64.startsWith('data:image')) loadBase64(base64)
				else alert('Invalid base64 PNG data URL.')
			})

			// TOOL BUTTONS
			document.getElementById('toolPencil').addEventListener('click', () => { currentTool = 'pencil'; updateToolUI() })
			document.getElementById('toolFill').addEventListener('click', () => { currentTool = 'fill'; updateToolUI() })
			document.getElementById('toolLine').addEventListener('click', () => { currentTool = 'line'; updateToolUI() })

			// keyboard shortcuts (optional): P = pencil, B = bucket/fill, L = line
			window.addEventListener('keydown', e => {
				if (e.key === 'p' || e.key === 'P') { currentTool = 'pencil'; updateToolUI() }
				if (e.key === 'b' || e.key === 'B') { currentTool = 'fill'; updateToolUI() }
				if (e.key === 'l' || e.key === 'L') { currentTool = 'line'; updateToolUI() }
			});
		}

		function updateToolUI() {
			const btnP = document.getElementById('toolPencil')
			const btnF = document.getElementById('toolFill')
			const btnL = document.getElementById('toolLine')
			btnP.classList.toggle('active', currentTool === 'pencil')
			btnF.classList.toggle('active', currentTool === 'fill')
			btnL.classList.toggle('active', currentTool === 'line')
			toolLabel.textContent = currentTool.charAt(0).toUpperCase() + currentTool.slice(1)
		}

		// helper to update a single cell's background if you've changed pixels programmatically
		// (used by setPixelIdx)
		// init call
		init();
	</script>
</body>

</html>
